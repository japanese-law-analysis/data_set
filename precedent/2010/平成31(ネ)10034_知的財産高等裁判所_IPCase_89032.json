{
  "trial_type": "IPCase",
  "date": {
    "era": "Reiwa",
    "year": 1,
    "month": 10,
    "day": 31
  },
  "case_number": "平成31(ネ)10034",
  "case_name": "損害賠償請求控訴事件",
  "court_name": "知的財産高等裁判所",
  "right_type": "特許権",
  "lawsuit_type": "民事訴訟",
  "lawsuit_id": "89032",
  "detail_page_link": "https://www.courts.go.jp/app/hanrei_jp/detail7?id=89032",
  "full_pdf_link": "https://www.courts.go.jp/app/files/hanrei_jp/032/089032_hanrei.pdf",
  "contents": "令和元年１０月３１日判決言渡\n平成３１年（ネ）第１００３４号  損害賠償請求控訴事件\n（原審・東京地方裁判所平成２９年（ワ）第３１７０６号）\n口頭弁論終結日  令和元年９月３日\n判          決\n控訴 人    株式会社パッセルインテグレーション\n訴訟代理人弁護士    中     村     隆     夫\n加     藤     伸     樹\n我     妻     崇     明\n被 控 訴 人    ソフトバンクロボティクス株式会社\n訴訟代理人弁護士    鮫     島     正     洋\n和     田     祐     造\n森     下          梓\n主        文\n１  本件控訴を棄却する。\n２  控訴費用は控訴人の負担とする。\n事 実 及 び 理 由\n第１  控訴の趣旨\n１  原判決を取り消す。\n２  被控訴人は，控訴人に対し，３億４９１５万５０００円及びこれに対する平\n成２９年１０月１８日から支払済みまで年５分の割合による金員を支払え。\n第２  事案の概要（略称は，特に断りのない限り，原判決に従う。）\n１  事案の要旨\n本件は，発明の名称を「情報管理方法，情報管理プログラム，及び情報管理\n装置」とする特許（特許第３７５４４３８号。請求項の数１５。以下「本件特\n許」という。）に係る特許権（以下「本件特許権」という。）を有していた控\n訴人が，被控訴人においてウェブサイト上で提供している別紙プログラム目録\n記載のプログラム（以下「被告プログラム」という。）が本件特許の特許請求\nの範囲の請求項１４に係る発明（以下「本件発明」という。）の技術的範囲に\n属し，被控訴人による被告プログラムのウェブサイト上での提供等が本件特許\n権の侵害に当たる旨主張して，被控訴人に対し，本件特許権侵害の不法行為に\n基づく損害賠償として３億４９１５万５０００円及びこれに対する不法行為\nの後の日である平成２９年１０月１８日（訴状送達の日の翌日）から支払済み\nまで民法所定の年５分の割合による遅延損害金の支払を求めた事案である。\n原判決は，被告プログラムは本件発明の技術的範囲に属すると認めることは\nできないから，その余の点について判断するまでもなく，控訴人の請求は理由\nがないとして，これを棄却した。\n控訴人は，原判決を不服として，本件控訴を提起した。\n２  前提事実\n以下のとおり訂正するほか，原判決の「事実及び理由」の第２の２記載のと\nおりであるから，これを引用する。\n⑴  原判決２頁１６行目から２０行目までを次のとおり改める。\n「  本件特許の特許請求の範囲の請求項１及び１４の記載は，次のとおりで\nある。\n【請求項１】\nコンピュータが情報を管理する情報管理方法であって，\n前記コンピュータに複数のノードそれぞれに対応付けて入力された管理\nすべき情報を，前記ノードを識別するノード識別情報に対応付けられた複\n数のノードデータを含む文書ファイルとして前記コンピュータが記憶する\n情報記憶ステップと，\n前記情報記憶ステップで記憶された前記文書ファイルの情報を前記コン\nピュータが表示する情報表示ステップと，\n前記ノードデータに含まれるスクリプトを前記コンピュータが実行する\n情報評価ステップとを備え，\n前記ノードデータは，ルートノードを除いて，当該ノードの親ノードを\n特定する親ノード識別情報を含んでおり，\n前記スクリプトは，当該ノードデータに含まれる変数データである自ノ\nード変数データと，当該ノードの直系上位ノードのノードデータに含まれ\nる変数データである上位ノード変数データを利用した演算を行って，前記\n自ノード変数データの値を求める代入用スクリプトを含んでおり，\n前記情報表示ステップは，前記親ノード識別情報を利用して，前記ノー\nドの木構造を表示する木構造表示ステップと，前記表示された木構造のノ\nードのうちの選択されたノードの前記自ノード変数データ，前記上位ノー\nド変数データ及び前記スクリプトを表示するノードデータテーブル表示ス\nテップを含み，\n前記情報評価ステップは，前記代入用スクリプトの実行により，前記自\nノード変数データの値を更新するステップを含む情報管理方法。\n【請求項１４】\n請求項１ないし１３のいずれか１項記載の情報管理方法における各ステ\nップを，コンピュータに実行させるための情報管理プログラム。\n⑷  本件発明の構成要件の分説\n本件発明は，請求項１記載の情報管理方法における各ステップを発明特\n定事項に含むものであるところ，かかる本件発明を構成要件に分説すると，\n次のとおりである（以下，頭書の記号に従って，「構成要件Ａ」などとい\nう。）。」\n(2)  原判決４頁１３行目の「本件ｂｅｈａｖｉｏｒ．ｘａｒ」を「本件ｂｅｈ\nａｖｉｏｒ．ｘａｒ１」と改め，同行末尾に行を改めて次のとおり加える。\n「ウ  被告プログラムの内容は，原判決別紙３－１被告プログラム説明書（以\n下「別紙被告プログラム説明書」という。）記載のとおりである。」\n⑶  原判決４頁１６行目の「甲４～６」を「甲４ないし７，３０ないし３３」\nと改める。\n３  争点\n⑴  被告プログラムの本件発明の技術的範囲の属否（争点１）\nア  構成要件ＡないしＤの充足性（争点１－１）\nイ  構成要件Ｅの充足性（争点１－２）\nウ  構成要件Ｆの充足性（争点１－３）\nエ  構成要件Ｇの充足性（争点１－４）\nオ  構成要件Ｈ及びＩの充足性（争点１－５）\n⑵  無効の抗弁の成否（争点２）\nア  本件特許出願の優先日前に頒布された刊行物である乙９（特開平６－１\n７５８５２号公報）に記載された発明（以下「乙９発明」という。）を主\n引用例とする本件発明の新規性又は進歩性の欠如（争点２－１）\nイ  本件特許出願の優先日前に頒布された刊行物である乙１６（特開平１０\n－６９３７９号公報）に記載された発明（以下「乙１６発明」という。）\nを主引用例とする本件発明の新規性又は進歩性の欠如（争点２－２）\nウ  本件特許は特許法３６条６項１号及び同条４項１号に違反しているか\n（争点２－３）\nエ  本件特許は特許法３６条６項２号に違反しているか（争点２－４）\n⑶  損害の発生の有無及びその額（争点３）\n４  争点に関する当事者の主張\n⑴  争点１（被告プログラムの本件発明の技術的範囲の属否）について\nア  争点１－１（構成要件ＡないしＤの充足性）について\n【控訴人の主張】\n(ア)  本件発明の特許請求の範囲（請求項１記載の各ステップを発明特定\n事項に含む請求項１４。以下同じ。）の記載によれば，構成要件Ｂの「管\n理すべき情報」は，ノードを識別する「ノード識別情報」に対応付けら\nれた「複数のノードデータ」を含む「文書ファイル」としてコンピュー\nタに記憶されるものであり，この「ノードデータ」は，「スクリプト」，\n「親ノード識別情報」，「自ノード変数データ」，「上位ノード変数デ\nータ」及び「木構造」を表示するための情報を含むものを意味する。\nまた，「ノード」は，「木構造」を前提とし，「木構造」は，数学の\n一分野であるグラフ理論に由来するところ，グラフ理論では，「グラフ」\nとは「いくつかの点とそれらを結ぶ何本かの線からなる図ないし構造」，\n「木」とは「閉路を含まないグラフ」，「閉路」とは「頂点を順につな\nいで輪にしたもの」とそれぞれ定義される（甲２３の１）。\nしかるところ，控訴人は，本件特許出願の当時，本件発明により表示\nされる図形には閉路を持つグラフが含まれることを前提としていたが，\n単に「グラフ」という用語でクレームすると，これが閉路を持つ「グラ\nフ」を意味するものとされ，「木」だけで表示されるケースは，より基\n本的な概念しか用いていないとして，クレームを充足しないものとされ\nるのを懸念したため，「木構造」という用語を選択したものであるから，\n本件発明の「木構造の表示」の用語は，閉路を含むグラフを表示するこ\nとを排除するものではない。したがって，構成要件Ｂの「ノード」は，\nノード（頂点）と２つのノードを結ぶエッジ（辺）により構成されるグ\nラフにおける頂点を意味するものであり，このグラフには，閉路を持つ\nものも，閉路を持たないものも含まれる。\nさらに，本件特許出願の願書に添付した明細書（以下，図面を含めて\n「本件明細書」という。甲３）の記載（【０００９】）に鑑みれば，構\n成要件Ｂの「文書ファイル」とは，テキストエディタ等で読むことので\nきるテキスト形式のファイルであり，１つの文書データを意味する。\n(イ)  別紙被告プログラム説明書の記載によれば，被告プログラムの構成\nは，原判決別紙４被告プログラムの構成（原告）（以下「別紙４」とい\nう。）記載のとおりである。\n(ウ)  被告プログラムは，ボックスを接続する形で本件ロボットのソフト\nウェアを実装することができる開発環境であり，別紙被告プログラム説\n明書及び別紙４に記載のとおり，コンピュータによって情報を管理する\nものであるから，構成要件Ａ（「コンピュータが情報を管理する情報管\n理方法」）を充足する。\n次に，被告プログラムにおいて表示されるフローダイアグラムは，閉\n路を含まず，結合線により結合されたボックスで構成されているから，\nこれらのボックスは，構成要件Ｂの「ノード」に該当し，各ボックスを\n識別するボックス識別番号（「ｉｄ」の番号）は，構成要件Ｂの「ノー\nド識別情報」に該当する。また，被告プログラムにおいてロボットの動\n作に関する情報がまとめられた「文書ファイル」であるｂｅｈａｖｉｏ\nｒ．ｘａｒ内で，ボックスに対応付けて入力されたスクリプトは，構成\n要件Ｂの「管理すべき情報」及び「ノードデータ」に該当する。そうす\nると，被告プログラムは，「ノードデータを含む文書ファイル」として\nコンピュータが記憶する「情報記憶ステップ」を備えているから，構成\n要件Ｂを充足する。\nさらに，被告プログラムは，「文書ファイル」であるｂｅｈａｖｉｏ\nｒ．ｘａｒを読み込んで表示し，ｂｅｈａｖｉｏｒ．ｘａｒに含まれる\nスクリプトを実行するステップを備えているから，構成要件Ｃ及びＤを\n充足する。\n【被控訴人の主張】\n(ア)  本件明細書の記載（【０００７】，【０００９】），構成要件Ｈ  が\n「自ノード変数データの値を更新するステップ」と規定していることに\n照らせば，構成要件Ｂの「管理すべき情報」は，変数データの値を意味\nするから，「情報管理方法」における情報及び当該情報を含む「文書フ\nァイル」（構成要件Ｂ）は，それ自体，多人数で共有し，再利用する価\n値のある，変数データの値を意味する。\nまた，構成要件Ｂの「複数のノードそれぞれに対応付けて入力された\n管理すべき情報」との文言によれば，構成要件Ｂの「ノード」は，管理\nすべき情報を含むものであり，木構造を前提とした概念である。\n次に，本件明細書の記載（【００２９】）によれば，構成要件Ｂの「ノ\nード識別情報」は，ノードを識別する情報であって，ノード生成時に自\n動的に一意の番号が付与される情報を意味する。そして，本件特許の特\n許請求の範囲の請求項２及び９の記載並びに本件明細書の記載（【００\n４２】，【００４９】）によれば，ノードの結合関係を表す参照リード\nは，構成要件Ｅの「親ノード識別情報」に基づく階層リードと区別され\nているから，構成要件Ｂの「ノード識別情報」は，ノードの結合関係を\n表す情報を含まないものを意味する。\n(イ)  被告プログラムの構成が別紙４記載のとおりであるとの控訴人の主\n張は，争う。\n別紙被告プログラム説明書の記載及び証拠（乙３ないし７，１９，２\n８ないし３１）によれば，被告プログラムの構成は，原判決別紙５被告\nプログラムの構成（被告）記載のとおりである。\n(ウ)  被告プログラムが管理するｂｅｈａｖｉｏｒ．ｘａｒに含まれるの\nはロボットを動作させるためのプログラムコードであって，人間がこの\n意味を読み取り，多人数で共有して再利用するものではないから，被告\nプログラムには「情報」に該当するものが存在しない。そうすると，被\n告プログラムは，本件ロボットを動作させるためのソフトウェアを開発\nするためのソフトウェア開発環境であり，構成要件Ａの「情報管理方法」\nであるとはいえず，構成要件Ｂの「管理すべき情報」，「ノード」及び\n「文書ファイル」を備えていない。\nまた，「木構造」は，階層構造を備えるものであるが，被告プログラ\nムのフローダイアグラムはプロセスを規定するものであって，階層構造\nを備えていないから，被告プログラムにおけるボックスは，構成要件Ｂ\nの「ノード」に該当するとはいえない。したがって，被告プログラムは，\n「ノードデータ」及び「情報記憶ステップ」を備えていない。\nさらに，被告プログラムには，同一のｉｄを有する複数のボックスデ\nータが存在するから，ｉｄによってボックスを識別することは不可能で\nある上，ｉｄは編集可能であって，固有の識別情報ではなく，ボックス\n生成時に自動的に一意の番号が付与されるものではないから，ｉｄは構\n成要件Ｂの「ノード識別情報」に該当するとはいえない。したがって，\n被告プログラムは，構成要件Ｂの「ノード識別情報」を備えていない。\n以上によれば，被告プログラムは，構成要件Ａ及びＢを充足しない。\nそして  上記のとおり，被告プログラムは，構成要件Ｂの「情報記憶\nステップ」，「文書ファイル」及び「ノードデータ」を備えていないか\nら，これらの存在を前提とする構成要件Ｃ及びＤも充足しない。\nイ  争点１－２（構成要件Ｅの充足性）について\n【控訴人の主張】\n(ア)  本件発明の構成要件Ｅの「親ノード」とは，あるノードに対して，\n当該ノードが属する順序系列内において，当該ノードに直近して先行す\nるノードを指し，構成要件Ｅの「ルートノード」とは，当該ノードが属\nする順序系列内における一番最初のノードを指し，「ルートノード」に\n対する「親ノード」は存在しない。\n次に，前記アの【控訴人の主張】のとおり，本件発明の「木構造の表\n示」は，閉路を含むグラフの表示を排除するものではなく，構成要件Ｂ\nの「ノード」は，ノード（頂点）とエッジ（辺）により構成されるグラ\nフにおける頂点を意味するものである。\n本件明細書の記載（【００４２】，【００４９】，【００５４】）に\nよれば，親子のノード間を接続するリードは「階層リード」と呼ばれ，\n「階層リード」は親子関係に基づいて表示されるから，「親」は，専ら\n木構造の表示におけるノード間のリードの接続に関するものを意味する。\nそして，構成要件Ｇの文言及び本件明細書の記載（【００３８】，【０\n０６０】）によれば，「木構造」は階層ごとに表示されるから，構成要\n件Ｅの「親ノード識別情報」は，階層ごとの木構造表示のために「親ノ\nード」を識別する機能を有する情報を意味する。\n(イ)  被告プログラムでは，各ボックスに入力コネクタと出力コネクタが\n含まれており，コネクタ同士を線でつなげることによって，ボックス間\nに結合関係が生じ（別紙被告プログラム説明書第２の３(2)），各ボック\nスは，コネクタを介して結合されると，出力コネクタのある結合元のボ\nックスから，入力コネクタのある結合先のボックスへと，結合ボックス\n同士の処理順序が指定される（別紙被告プログラム説明書第２の４ア）。\nコネクタを介したボックスの結合により各ボックスの処理順序が指定さ\nれることは，①ボックスの結合関係を無視した順序で各ボックスのスク\nリプト処理が行われることがないこと，②「Ｐｅｐｐｅｒプログラミン\nグ  基本動作からアプリの企画・演出まで」と題する解説書（甲７の２\n９頁）において，ボックスの結合線に従って「最初のボックスから次の\nボックスへと，処理が順番に移って」いくことを「順序実行」と呼んで\nいることからも明らかである。\nしたがって，被告プログラムにおいては，各ボックスをコネクタを介\nして結合することによって，ボックス間に「階層関係」が生じ，先に処\n理される（出力コネクタのある）「親ボックス」と，後に処理される（入\n力コネクタのある）「子ボックス」の親子関係が成立する。\n(ウ)ａ  原判決別紙３－２（以下「別紙３－２」という。甲１７）の本件\nｂｅｈａｖｉｏｒ．ｘａｒ１をフローダイアグラムに表示した場合の\n接続関係は，次のとおりである。\n(a)  各ボックスのｉｄは，次のとおりである。ボックス自体とは異\nなる各「内壁コネクタ」（左側内壁コネクタ及び右側内壁コネクタ）\n（原判決別紙６（以下「別紙６」という。）の図１及び図２参照）\nの「ｉｄ」は「０」である。\nSet Language  Localized Text  Say Text  Say\nid=\"2\"\n（１８行）\nid=\"5\"\n（１８０行）\nid=\"2\"\n（１２５行）\nid=\"1\"\n（９２行）\n⒝  別紙３－２のｒｏｏｔボックスタグ内の結合情報（３０１行ない\nし３０３行）及びＳａｙボックスタグ内の結合情報（２９２行ない\nし２９４行）は，次のとおりである。各結合情報の「inputowner=」\n及び「outputowner=」の次に記載された数字部分の「\"1\"」，「\"2\"」\n及び「\"5\"」は，括弧内の行（例えば，「１８０行」）において定\n義 さ れ た ボ ッ ク ス の 「 ｉ ｄ 」 の 番 号 を 表 す （ 例 え ば ，\n「inputowner=\"5\"」及び「outputowner=\"5\"」の「\"5\"」は，「ｉｄ\n５」のＬｏｃａｌｉｚｅｄ  Ｔｅｘｔボックスを意味する。）。\n【ｒｏｏｔボックスタグ内の結合情報】\n301: <Link inputowner=\"1\" indexofinput=\"2\" outputowner=\"2\"\nindexofoutput=\"3\" />\n302: <Link inputowner=\"0\" indexofinput=\"4\" outputowner=\"1\"\nindexofoutput=\"4\" />\n303: <Link inputowner=\"2\" indexofinput=\"2\" outputowner=\"0\"\nindexofoutput=\"2\" />\nｒｏｏｔボックスのフローダイアグラムは，①「ｉｄ０」（ｒｏｏ\nｔボックスの左側内壁コネクタ）から「ｉｄ２」（Ｓｅｔ  Ｌａｎｇ\nｕａｇｅボックス）へ（３０３行），②「ｉｄ２」（Ｓｅｔ  Ｌａｎ\nｇｕａｇｅボックス）から「ｉｄ１」（Ｓａｙボックス）へ（３０１\n行），③「ｉｄ１」（Ｓａｙボックス）から「ｉｄ０」（ｒｏｏｔボ\nックスの右側内壁コネクタ）へ（３０２行）と結合していることを表\nしている。\n【Ｓａｙボックスタグ内の結合情報】\n292: <Link inputowner=\"0\" indexofinput=\"4\" outputowner=\"2\"\nindexofoutput=\"4\" />\n293: <Link inputowner=\"5\" indexofinput=\"2\" outputowner=\"0\"\nindexofoutput=\"2\" />\n294: <Link inputowner=\"2\" indexofinput=\"2\" outputowner=\"5\"\nindexofoutput=\"3\" />\nＳａｙボックスのフローダイアグラムは，①「ｉｄ０」（Ｓａｙボ\nックスの左側内壁コネクタ）から「ｉｄ５」（Ｌｏｃａｌｉｚｅｄ  Ｔ\nｅｘｔボックス）へ（２９３行），②「ｉｄ５」（Ｓｅｔ  Ｌａｎｇ\nｕａｇｅボックス）から「ｉｄ２」（Ｓａｙ  Ｔｅｘｔボックス）へ\n（２９４行），③「ｉｄ２」（Ｓａｙ  Ｔｅｘｔボックス）から「ｉ\nｄ０」（Ｓａｙボックスの右側内壁コネクタ）へ（２９２行）と結合\nしていることを表している。\nそして，被告プログラムにおいては，あるボックスの入力コネクタ\nに結合されている出力コネクタ及び当該出力コネクタを有しているボ\nックスの情報がｂｅｈａｖｉｏｒ．ｘａｒという文書ファイル上に記\n載されるから（別紙被告プログラム説明書第２の３(2)），ボックス及\nびコネクタ同士の結合情報が，ボックスデータの一部としてｂｅｈａ\nｖｉｏｒ．ｘａｒに集積され，その結合情報によってボックス間の親\n子関係を読み取り，あるボックスに対する親ボックスを特定すること\nができる。\nしたがって，上記結合情報のうち，ボックスの親ボックスを特定す\nる情報（例えば，３０１行の「inputowner=\"1\"」に対する「outputow\nner=\"2\"」）は，構成要件Ｅの「親ノード」を特定する「親ノード識別\n情報」に該当する。\nｂ  また，被告プログラムにおいては，他のボックスの出力コネクタと\nの結合情報を持たないボックスが存在し，これは，当該ボックスが属\nする順序系列内における一番最初のボックスとなる。\nしたがって，被告プログラムにおけるボックスのうち，当該ボック\nスの入力コネクタと他のボックスの出力コネクタとの結合情報を含ま\nない特定のボックスが，構成要件Ｅの「ルートノード」に該当する。\nｃ  以上によれば，被告プログラムは，構成要件Ｅを充足する。\n(エ)  （当審における控訴人の追加主張）\nａ  別紙７－１（甲２５の１）記載のｂｅｈａｖｉｏｒ．ｘａｒ（以下\n「本件ｂｅｈａｖｉｏｒ．ｘａｒ２」という。）をフローダイアグラ\nムに表示した場合の接続関係は，次のとおりである。\n各ボックスのｉｄは，次のとおりである。ボックス自体とは異なる\n「内壁コネクタ」（左側内壁コネクタ及び右側内壁コネクタ）（別紙\n７－２（甲２５の２）参照）の「ｉｄ」は「０」である。\nSet Language  Localized Text  Say Text\nid=\"2\"\n（１８行）\nid=\"5\"\n（１４７行）\nid=\"3\"\n（９２行）\n別紙７－１のｒｏｏｔボックスタグ内の結合情報（２５９行ないし\n２６２行）は，次のとおりである。各結合情報の「inputowner=」及び\n「outputowner=」の次に記載された数字部分の「\"2\"」，「\"3\"」及び\n「\"5\"」は，ボックスの「ｉｄ」の番号を表す。\n259: <Link inputowner=\"3\" indexofinput=\"2\" outputowner=\"5\"\nindexofoutput=\"3\" />\n260: <Link inputowner=\"5\" indexofinput=\"2\" outputowner=\"2\"\nindexofoutput=\"3\" />\n261: <Link inputowner=\"2\" indexofinput=\"2\" outputowner=\"0\"\nindexofoutput=\"2\" />\n262: <Link inputowner=\"0\" indexofinput=\"4\" outputowner=\"3\"\nindexofoutput=\"4\" />\n上記結合情報は，①「ｉｄ０」（ｒｏｏｔボックスの左側内壁コネ\nクタ）から「ｉｄ２」（Ｓｅｔ  Ｌａｎｇｕａｇｅボックス）へ（２\n６１行），②「ｉｄ２」（Ｓｅｔ  Ｌａｎｇｕａｇｅボックス）から\n「ｉｄ５」（Ｌｏｃａｌｉｚｅｄ  Ｔｅｘｔボックス）へ（２６０行），\n③「ｉｄ５」（Ｌｏｃａｌｉｚｅｄ  Ｔｅｘｔボックス）から「ｉｄ\n３」（Ｓａｙ  Ｔｅｘｔボックス）へ（２５９行），④「ｉｄ３」（Ｓ\nａｙ  Ｔｅｘｔボックス）から「ｉｄ０」（ｒｏｏｔボックスの右側\n内壁コネクタ）へ（２６２行）と結合していることを表している。\nしたがって，前記(ウ)ａと同様に，上記結合情報のうち，ボックス\nの親ボックスを特定する情報（例えば，２５９行の「inputowner=\"3\"」\nに対する「outputowner=\"5\"」）は，構成要件Ｅの「親ノード」を特定\nする「親ノード識別情報」に該当する。\nｂ  また，前記(ウ)ｂと同様に，被告プログラムにおけるボックスのう\nち，当該ボックスの入力コネクタと他のボックスの出力コネクタとの\n結合情報を含まない特定のボックスが構成要件Ｅの「ルートノード」\nに該当する。\nｃ  以上によれば，被告プロクラムは，構成要件Ｅを充足する。\n【被控訴人の主張】\n(ア)  構成要件Ｅは，「親ノード識別情報」は，「ノードデータ」に含ま\nれると規定している。本件明細書の記載（【００３６】，【００３８】\nないし【００４２】，図２ないし図４，図９，図１４）によれば，構成\n要件Ｅの「ノードデータ」は，ノードを示す特定の開始タグと，そのエ\nンドタグとの間に挟まれた領域内のデータを意味するから，構成要件Ｅ\nの「親ノード識別情報」は，ノードを示す特定の開始タグと，そのエン\nドタグとの間に挟まれた領域内のデータに含まれるものを意味する。\nまた，本件明細書の記載（【００１０】，【００１３】，【００４９】，\n図６，図８）によれば，構成要件Ｅの「親ノード」は，木構造を前提と\nした概念であるところ，「木構造」は，基本となるルートノードから複\n数の要素に枝分かれをした階層構造を意味するから，「親」は，１つの\n基本となる要素から複数の要素に枝分かれをした階層構造によって規定\nされる親子関係における親を意味する。\n(イ)  被告プログラムのフローダイアグラムは，ｒｏｏｔボックス，Ｓｅ\nｔ  Ｌａｎｇｕａｇｅボックス，Ｓａｙボックス及びｒｏｏｔボックス\nの実行順序の処理の流れを定めたものであり，ｒｏｏｔボックスから出\nてｒｏｏｔボックスに戻る閉路を構成しており，階層構造は存在しない\nから，「木構造」であるとはいえず，親子及び上下という概念は存在し\nない。したがって，被告プログラムは，「木構造」を前提とした概念で\nある構成要件Ｅの「親ノード」及び「ルートノード」を備えていない。\nまた，控訴人が構成要件Ｅの「親ノード識別情報」であると主張する\nＬｉｎｋタグ内の情報は，ボックス間の結合関係を表すものである上，\n各ボックスのＢｏｘタグの開始タグとエンドタグとに挟まれた領域の外\nにあり（例えば，本件ｂｅｈａｖｉｏｒ．ｘａｒ１のＳｅｔ  ｌａｎｇ\nｕａｇｅボックス（１８行ないし９１行）に係るＬｉｎｋタグは，この\nボックスの領域外である３０１行ないし３０３行に存在する。），「ノ\nードデータ」に含まれているといえないから，構成要件Ｅの「親ノード\n識別情報」に当たらない。\n以上によれば，被告プログラムは，「親ノード」，「ルートノード」\n及び「親ノード識別情報」を備えていないから，構成要件Ｅを充足しな\nい。\n(ウ)  当審における控訴人の追加主張は，争う。\nウ  争点１－３（構成要件Ｆの充足性）について\n【控訴人の主張】\n(ア)  構成要件Ｆの文言及び本件明細書の記載（【００３１】，【００３\n２】）によれば，構成要件Ｆの「（直系）上位ノード」とは，順序系列\n内において，当該ノードに先行するノードを意味し，「上位」は，専ら\n下位ノードによるデータの承継に関するものを意味する。また，本件明\n細書の記載（【０００７】）によれば，「上位ノード変数データ」が表\n示されることによって，選択したノードで用いられている上位ノード変\n数データを容易に把握することができ，管理すべき情報の更新を，簡単\nかつ効率的に行うことができるのであるから，構成要件Ｆの「上位ノー\nド変数データ」は，当該ノードの直系上位ノードのノードデータに含ま\nれる変数データを意味する。そして，本件明細書の記載（【００５６】，\n【００６６】）によれば，「変数データ」は，変数名及び変数の値の２\nつの要素からなるものであり，変数名のみによって特定することもでき\nるものである。\n次に，構成要件Ｆの「代入用スクリプト」には，単純な代入処理だけ\nでなく，数式を含んだ代入処理を行うスクリプトも含まれる。\n(イ)  被告プログラムにおいて，Ｓｅｔ  Ｌａｎｇｕａｇｅボックス，Ｓ\nａｙボックス及びＬｏｃａｌｉｚｅｄ  Ｔｅｘｔボックスは，順序系列\n内において，Ｓａｙ  Ｔｅｘｔボックスに先行するボックスであるから\n（別紙被告プログラム説明書の図１１及び図２２），「（直系）上位ノ\nード」を有し，その変数名又は変数の値は，「上位ノード変数データ」\nに該当する。\n次に，別紙４記載の被告プログラムの構成ｆにおいては，被告プログ\nラムのＬｏｃａｌｉｚｅｄ  Ｔｅｘｔボックスは，直系上位ノードであ\nるＳｅｔ  Ｌａｎｇｕａｇｅボックスにおいて入力された，上位ノード\n変数データである変数ｌａｎｇの値である「Ｅｎｇｌｉｓｈ」や「Ｊａ\nｐａｎｅｓｅ」を利用して演算を行い，Ｌｏｃａｌｉｚｅｄ  Ｔｅｘｔ\nボックスの自ノード変数データである「Ｈｅｌｌｏ」や「こんにちは」\nを決定しているから，被告プログラムは，構成要件Ｆの「代入用スクリ\nプト」を備えている。\nまた，別紙４記載の被告プログラムの構成ｆ’においては，被告プロ\nグラムのＳａｙ  Ｔｅｘｔボックスは，「親からの変数を取得」機能を\n使用する場合，直系上位ノードであるＳａｙボックスにおいて入力され\nた上位ノード変数データである「Ｓｐｅｅｄ（％）」や「Ｖｏｉｃｅ  Ｓ\nｈａｐｉｎｇ（％）」の値を利用して演算を行うことにより，Ｓａｙ\nＴｅｘｔボックスの自ノード変数であるｓｅｎｔｅｎｃｅに代入し，Ｓ\nａｙ  Ｔｅｘｔボックスの自ノード変数データであるｓｅｎｔｅｎｃｅ\nの値を更新しているから，被告プログラムは，構成要件Ｆの「代入用ス\nクリプト」を備えている。\n以上のとおり，被告プログラムは，「（直系）上位ノード」，「上位\nノード変数データ」及び「代入用スクリプト」を備えているから，構成\n要件Ｆを充足する。\n【被控訴人の主張】\n(ア)  構成要件Ｆの文言によれば，「上位ノード変数データ」は，「直系\n上位ノードのノードデータに含まれる」ものであるところ，「ノードデ\nータ」は，ノードを示す特定の開始タグと，そのエンドタグとの間に挟\nまれた領域内のデータであるから，「上位ノード変数データ」は，直系\n上位ノードのノードを示す特定の開始タグと，そのエンドタグとの間に\n挟まれた領域内のデータに含まれる変数データを意味する。\nまた，本件発明は「木構造」を前提とするものであるから，構成要件\nＦの「直系上位ノード」も「木構造」を前提とした概念であるところ，\n「直系」とは，一般に，人と人との間の血統が親子の関係で続いている\n系統を意味するから，「直系上位ノード」は，木構造を前提として，自\nノードと親子関係にあり，自ノードよりもルートノードに近いノードを\n意味する。\nさらに，構成要件Ｆは，「代入用スクリプト」は，「上位ノード変数\nデータを利用した演算」を行って「自ノード変数データの値を求める」\nものである旨を規定しているところ，「上位ノード変数データ」の変数\n名だけでは，変数名を利用した演算を行って，自ノード変数データの値\nを求めることは不可能であり，本件明細書の記載（【００３１】，【０\n０３２】）にも照らせば，「上位ノード変数データ」は，変数名のみな\nらず，変数の値を意味するか，少なくとも変数の値を含むものと解釈さ\nれる。\n次に，構成要件Ｄは，「前記ノードデータに含まれるスクリプト」と\n規定し，構成要件Ｆは，この記載を受けて「前記スクリプトは…自ノー\nド変数データの値を求める代入用スクリプトを含んでおり」と規定して\nいるから，構成要件Ｆの「代入用スクリプト」は，自ノードのノードデ\nータに含まれるものでなければならない。また，本件明細書記載の実施\n例（【００７２】，【００７３】）に照らせば，構成要件Ｆの「代入用\nスクリプト」は，親ノード変数データの値を自ノード変数データの値と\nして代入するスクリプトを意味する。\n(イ)  被告プログラムのフローダイアグラムにおける処理の流れは，閉路\nを構成し，親子，上下という概念は存在しないから，被告プログラムは，\n構成要件Ｆの「（直系）上位ノード」及び「上位ノード変数データ」を\n利用した演算を行って自ノード変数データの値を求める「代入用スクリ\nプト」を備えていない。\n控訴人の被告プログラムの構成ｆに関する主張についてみると，変数\nｌａｎｇは，Ｓｅｔ  Ｌａｎｇｕａｇｅボックスに含まれる一時変数（ソ\nースコードの実行後にはメモリから破棄される値を一時的に格納するも\nの）であり，自ノードであるＳａｙボックス内に記載されたスクリプト\nには利用されておらず，また，ｌａｎｇの値はＳｅｔ  Ｌａｎｇｕａｇ\nｅボックスに記憶されていない。さらに，被告プログラムでは，Ｌｏｃ\nａｌｉｚｅｄ  Ｔｅｘｔボックスに予め記載された値である「Ｈｅｌｌ\nｏ」や「こんにちは」という値を，Ｓｅｔ  Ｌａｎｇｕａｇｅボックス\nの変数データを用いて選択しているにすぎず，自ボックス変数に上位ボ\nックス変数の値を代入していないから，構成ｆは，構成要件Ｆの「代入\n用スクリプト」に当たらない。\n次に，控訴人の被告プログラムの構成ｆ’に関する主張についてみる\nと，被告プログラムのＳａｙ Ｔｅｘｔボックスにおける「Ｓｐｅｅｄ\n（％）」及び「Ｖｏｉｃｅ  Ｓｈａｐｉｎｇ（％）」は，いずれも上位\nノード変数ではなく，Ｓａｙ  Ｔｅｘｔボックスの自ボックス変数であ\nる。また，Ｓａｙ  Ｔｅｘｔボックスが「親からの継承」機能によって\n「Ｓｐｅｅｄ（％）」及び「Ｖｏｉｃｅ  Ｓｈａｐｉｎｇ（％）」の値\nを継承する際，Ｓａｙボックスはその継承元のボックスであるところ，\nＳａｙボックスとＳａｙ  Ｔｅｘｔボックスは結合情報で結合されてい\nないから，ＳａｙボックスはＳａｙ  Ｔｅｘｔボックスの上位ノードに\n該当しない。\nさらに，「Ｓｐｅｅｄ（％）」及び「Ｖｏｉｃｅ  Ｓｈａｐｉｎｇ（％）」\nは，直系上位ノードのノードデータに含まれるものではなく，上位ノー\nドのノードデータ中に変数の値を含むものではない。\n加えて，本件ｂｅｈａｖｉｏｒ．ｘａｒ１には，「親からの継承」機\n能を実行するスクリプトは存在しないから，被告プログラムは，自ノー\nドのノードデータに含まれる代入用スクリプトに利用され，代入用スク\nリプトが親ノード変数データの値を自ノード変数データの値として代入\nするスクリプトという構成が存在しない。\n以上のとおり，被告プログラムは，「（直系）上位ノード」，「上位\nノード変数データ」及び「代入用スクリプト」を備えていないから，構\n成要件Ｆを充足しない。\nエ  争点１－４（構成要件Ｇの充足性）について\n【控訴人の主張】\n(ア)  構成要件Ｇの「木構造表示ステップ」について\nａ  本件発明の「木構造の表示」の用語は，閉路を含むグラフを表示す\nることを排除するものではなく，構成要件Ｂの「ノード」は，ノード\n（頂点）と２つのノードを結ぶエッジ（辺）により構成されるグラフ\nにおける頂点を意味するものであり，このグラフには，閉路を持つも\nのも，閉路を持たないものも含まれることは，前記アの【控訴人の主\n張】の主張のとおりである。\n被告プログラムは，Ｌｉｎｋタグ内のｉｎｐｕｔｏｗｎｅｒ（入力\n側・子）とｏｕｔｐｕｔｏｗｎｅｒ（出力側・親）により結合情報を\n認識し，これに従ってフローダイアグラム上でボックスとボックス間\nの結合線で表現することによって「木構造」を表示している。また，\nＳａｙボックスのフローダイアグラムの表示において，左側の内壁コ\nネクタと右側の内壁コネクタは別の図形（点）として表示されており，\nここに閉路は存在しないから，「親ノード識別情報」を利用して「ノ\nード」の「木構造」を表示しているといえる。\nしたがって，被告プログラムは，構成要件Ｇの「木構造表示ステッ\nプ」を備えている。\nｂ  この点に関し，原判決は，本件発明の「木構造」とは，ノードを表\n示するラベルとラベル間を接続する結合線であるリードから構成され\nる図として表現される表示に関する概念であって，基本となる要素，\nすなわちルートから複数の要素に枝分かれをした階層構造を意味し，\n閉路を含まないものと解される，被告プログラムのＳａｙボックスの\nフローダイアグラムにおけるボックスの接続関係は，Ｓａｙボックス\nから出発してＳａｙボックスに戻る閉路として表示されており，「木\n構造」であるとはいえないから，被告プログラムは，「木構造」を表\n示するものとはいえず，構成要件Ｇの「木構造表示ステップ」を備え\nていない旨判断した。\nしかしながら，前記ａのとおり，本件発明の「木構造の表示」の用\n語は，閉路を含むグラフを表示することを排除するものではなく，ま\nた，Ｓａｙボックスのフローダイアグラムの表示において，左側の内\n壁コネクタと右側の内壁コネクタは別の図形（点）として表示されて\nおり，ここに閉路は存在しない。\nしたがって，被告プログラムは，「親ノード識別情報」を利用して\n「ノード」の「木構造」を表示しているといえるから，原判決の上記\n判断は誤りである。\n(イ)  構成要件Ｇの「ノードデータテーブル表示ステップ」について\nａ  本件明細書の記載（【００４６】）によれば，「デザインテーブル\n２０は，ツリービューア１０に表示されたノードのうちの選択された\nノードが有する情報を表示する領域であ」ることからすると，構成要\n件Ｇの「ノードデータテーブル表示ステップ」にいう「テーブル」と\nは，情報を表示する領域を意味する。\n被告プログラムのフローダイアグラム画面上でボックスを選択して\nダブルクリックすると，当該ボックスに対応して管理されているスク\nリプトを「スクリプトエディタ」によって表示することができるから\n（別紙被告プログラム説明書の図１４），被告プログラムは，「スク\nリプト」を表示する「ノードデータテーブル表示ステップ」を備えて\nいる。\nｂ  被告プログラムのフローダイアグラム画面上でボックスを選択して\nクリックすると，右下に区分けされたインスペクタという名称のウィ\nンドウ（以下「インスペクタ」という。）に，①当該ボックスが有し\nている入力・出力コネクタの名称，②当該ボックスの変数名が表示さ\nれる。インスペクタ上のアイコンをクリックすると，当該ボックスの\nコネクタや変数の追加，コネクタの名称やタイプ等の編集，削除をす\nることができる。このインスペクタに表示された入力コネクタの名称\nは，スクリプトエディタにより表示されるスクリプトにも含まれてい\nる。\nこのうち，上記②の当該ボックスの変数名は，自ノード変数データ\nを表示するものである（例えば，別紙被告プログラム説明書の図１５\n及び図１６記載の「変数：Ｖｏｉｃｅ  Ｓｈａｐｉｎｇ（％）」）。\nしたがって，被告プログラムは，「自ノード変数データ」を表示す\nる「ノードデータテーブル表示ステップ」を備えている。\nｃ  次に，入力コネクタには，アプリを実行した際に，直近の親ボック\nスから引き渡される値が，当該コネクタに対応した引数へ書き込まれ\nる。例えば，被告プログラムでは，Ｓａｙ  Ｔｅｘｔボックスの変数\nであるｐは，Ｓａｙ  Ｔｅｘｔボックスの入力コネクタ”ｏｎＩｎｐ\nｕｔ＿ｏｎＳｔａｒｔ（）”という関数（別紙３－２の１５０行）の\n構成要素であり，直系上位ノードであるＬｏｃａｌｉｚｅｄ  Ｔｅｘ\nｔボックスの出力コネクタｏｎＳｔｏｐｐｅｄ（Ｓｅｌｆ，ｓｅｎｔ\nｅｎｃｅｓ[ｓＤｅｆａｕｌｔＬａｎｇ])（別紙３－２の２１９行）か\nら出力された値を受け取る，コネクタの内部領域である。\nそして，入力コネクタとは，親ボックスから引き渡される値を記憶\nする変数が図形化されたものであり，入力コネクタの名称が構成要件\nＧにおける「上位ノード変数データ」に該当する。この入力コネクタ\nの名称は，インスペクタに表示される。\nしたがって，インスペクタ及びスクリプトエディタにおける入力コ\nネクタの名称に関する情報の表示は，上位ノード変数データを表示す\nるものであるから，被告プログラムは，「上位ノード変数データ」を\n表示する「ノードデータテーブル表示ステップ」を備えている。\nｄ  被告プログラムの構成ｇ’に関し，被告プログラムのＳａｙ  Ｔｅ\nｘｔボックスの「スクリプトエディタ」において「親からの変数を取\n得」機能を使う場合，上位ノードであるＳａｙボックスの変数から利\n用可能なものを一覧表示する機能がある。\nしたがって，被告プログラムは，「上位ノード変数データ」を表示\nする「ノードデータテーブル表示ステップ」を備えている。なお，本\n件発明において，インスペクタとスクリプトエディタを同時に表示す\nる必要はないが，被告プログラムにおいては，スクリプトエディタを\nインスペクタと同時に表示することも可能である。\nｅ  以上によれば，被告プログラムは，構成要件Ｇの「自ノード変数デ\nータ」，「上位ノード変数データ」及び「スクリプト」を表示する「ノ\nードデータテーブル表示ステップ」を備えている。\nｆ  この点に関し原判決は，①構成要件Ｇの「ノードデータテーブル表\n示ステップ」にいう「ノードデータテーブル」とは，「ノードデータ」\nの一覧表であり，上位ノード変数データ，自ノード変数データ及び代\n入用スクリプトを同時に表示するものと解される，②本件明細書の【０\n０３２】の記載から，「ノードデータテーブル」が表示する「ノード\n変数データ」は，変数の値を意味すると解されるとした上で，③被告\nプログラムの構成ｇについて被告プログラムのフローダイアグラム画\n面上のインスペクタに表示された入力コネクタの名称は変数の値では\nないから，「上位ノード変数データ」に当たらず，また，被告プログ\nラムの構成ｇ’についてインスペクタ上にＳａｙ  Ｔｅｘｔボックス\nの変数Ｓｐｅｅｄ（％）の値が表示されるが（別紙被告プログラム説\n明書の図１９），これはＳａｙ  Ｔｅｘｔボックスにおいて表示され\nるものであり，自ノード変数を表示しているものと認められ，「上位\nノード変数データ」を表示しているとみることはできないから，被告\nプログラムは，一覧表として「自ノード変数データ」及び「上位ノー\nド変数データ」を同時に表示しているということはできない，④さら\nに，「親からの継承」の機能に関して，本件ｂｅｈａｖｉｏｒ．ｘａ\nｒ１内に，自ノード変数データ及び上位ノード変数データを利用した\n演算を行って自ノード変数データの値を求める「代入用スクリプト」\nがあると認めるに足りる証拠はないとして，被告プログラムは，構成\n要件Ｇの「自ノード変数データ，前記上位ノード変数データ及び前記\nスクリプトを表示するノードデータテーブル表示ステップ」を備えて\nいない旨判断した。\nしかしながら，本件明細書の記載（【００４６】，【００７９】，\n図６）によれば，本件明細書では，図６の「デザインテーブル」に示\nすように，代入用スクリプト表示領域，生成用スクリプト表示領域，\n操作ボタン表示領域の表示は表形式というよりは，個々の情報をまと\nめて表示する領域という意味で「テーブル」という用語が使われてお\nり，その領域で表示すべき情報を，画面上でひとまとめに配置するか，\n分割して配置するかは，設計事項にすぎない。加えて，本件発明の技\n術的思想に照らせば，「ノードデータテーブル表示ステップ」は，表\n示された木構造の個々のノードに対応付けられた詳細情報を簡単に表\n示することができること（【０００９】）により，文書ファイル（プ\nログラム）の編集を容易にするためのものであるから，一覧表でなけ\nればならない等との制約を付けて解釈されるべきではない。\nまた，本件明細書の【００３２】における「変数の値（「変数デー\nタ」と記述する場合もある。）」との記載は，「変数データ」という\n用語を，文脈によって，変数の値を指す意味で用いることもあるとい\nう注意書きであると理解できること，「変数データ」は，変数名と変\n数の型を意味するというのが，プログラミングに関する通常の用語で\nあること（甲２４），実質的にも，本件発明が「ノードデータテーブ\nル表示ステップ」において上位ノード変数データを表示させる目的は，\n表示された木構造の個々のノードに対応付けられた詳細情報を簡単に\n表示することができる（【０００９】）ことにより，文書ファイル（プ\nログラム）の編集を容易にする点にあり，変数名が分かれば，その目\n的を達成することができることからすると，本件発明の「変数データ」\nは，本件明細書において文脈上変数の値を意味すべき場合を除き，変\n数名を指すと解すべきである。\nさらに，別紙３の２の「１５３行」では，「self.getParameter(\"S\npeed (%)\")」は，ＳａｙボックスのＳｐｅｅｄ（％）の値を代入し，\nこれと自ノード変数データを組み合わせて発話に関する変数ｓｅｎｔ\nｅｎｃｅを求めているから，「代入用スクリプト」に該当する。\nしたがって，原判決の上記判断は，その前提を欠くものであって，\n誤りである。\n(ウ)  小括\n前記(ア)及び(イ)によれば，被告プログラムにおける「情報表示ステ\nップ」は，「木構造表示ステップ」と「ノードデータテーブル表示ステ\nップ」を含むものといえるから，構成要件Ｇを充足する。\n【被控訴人の主張】\n(ア)  前記イの【被控訴人の主張】のとおり，「木構造」は，基本となる\nルートノードから複数の要素に枝分かれをした階層構造を意味するとこ\nろ，被告プログラムのフローダイアグラムは，ｒｏｏｔボックス，Ｓｅ\nｔ  Ｌａｕｇｕａｇｅボックス，Ｓａｙボックス，ｒｏｏｔボックスと\nいう順序の処理の流れを定めており，ｒｏｏｔボックスから出てｒｏｏ\nｔボックスに戻る閉路を構成しているから，階層構造は存在せず，親子\n及び上下という概念は存在しない。\nしたがって，被告プログラムは，「木構造」を備えていないから，構\n成要件Ｇの「木構造表示ステップ」を備えていない。\n(イ)ａ  「テーブル」は表を意味すること，本件明細書の記載（【００６\n５】，【００６６】，【００５７】，図６，図９，図１０，図１３）\nによれば，構成要件Ｇの「ノードデータテーブル表示ステップ」は，\n変数名と変数の値とを表形式で表示するステップを意味し，また，自\nノード変数データ，上位ノード変数データ並びに当該自ノード変数デ\nータ及び上位ノード変数データを用いた代入用スクリプトを，全て同\n時に表示するものを意味する。\nｂ  この点に関し，控訴人は，控訴人主張の被告プログラムの構成 g に\n関し，インスペクタに表示される入力コネクタの名称が「上位ノード\n変数データ」に該当する旨主張するが，入力コネクタの名称は，コネ\nクタ名であって変数ではない上，変数の値を含まないから，構成要件\nＧの「上位ノード変数データ」に当たらない。\nまた，控訴人主張の被告プログラムの構成 g’は，Ｓａｙ  Ｔｅｘ\nｔボックスのスクリプトエディタに表示される「ｐ」は，前記ウの【被\n控訴人の主張】のとおり，自ボックス関数の引数であって上位ノード\n変数ではなく，一時変数であり，ｐの値はＳａｙ  Ｔｅｘｔボックス\nに記憶されておらず，被告プログラムにおいてｐの値を表示すること\nはできないから，構成要件Ｇの「上位ノード変数データ」に当たらな\nい。\nそして， 被告プログラムにおいて，「親からの変数を取得」機能に\nよって表示されるのは，変数名にとどまり，変数の値は表示されない\nから，「親からの変数を取得」機能による表示は「上位ノード変数デ\nータ」に当たらない。\nしたがって，被告プログラムは，「上位ノード変数データ」を表示\nする「ノードデータテーブル表示ステップ」を備えていない。\nｃ  以上によれば，被告プログラムは，構成要件Ｇの「自ノード変数デ\nータ」，「上位ノード変数データ」及び「スクリプト」を表示する「ノ\nードデータテーブル表示ステップ」を備えていない。\n(ウ)  前記(ア)及び(イ)によれば，被告プログラムは，「木構造表示ステ\nップ」及び「ノードデータテーブル表示ステップ」をいずれも備えてい\nないから，構成要件Ｇを充足しない。\nオ  争点１－５（構成要件Ｈ及びＩの充足性）について\n【控訴人の主張】\n(ア)  「更新」とは，文書ファイルを変更するか否かに関わらず，自ノー\nド変数データの値を更新することを意味し，構成要件Ｈの「更新するス\nテップ」は，このような意味での「更新」を行うステップを意味する。\n被告プログラムでは，Ｓａｙ Ｔｅｘｔボックスの自ノード変数である\nｓｅｎｔｅｎｃｅの値が，「代入用スクリプト」の実行によって導かれ\nるところ，ｓｅｎｔｅｎｃｅの値は，直系上位ノードであるＳａｙボッ\nクスの「Ｓｐｅｅｄ（％）」及び「Ｖｏｉｃｅ  Ｓｈａｐｉｎｇ（％）」\nの値の設定や，Ｓｅｔ  Ｌａｎｇｕａｇｅボックスで設定した言語，Ｌ\nｏｃａｌｉｚｅｄ  Ｔｅｘｔボックスで言語に対応して入力されるあい\nさつ文に応じて更新されるから，被告プログラムは，構成要件Ｈの「更\n新するステップ」を備えており，構成要件Ｈを充足する。\n(イ)  以上によれば，被告プログラムは，構成要件ＡないしＨを充足する\nから，これを前提とする構成要件Ｉを充足する。\nしたがって，被告プログラムは，本件発明の構成要件を全て充足する\nから，その技術的範囲に属する。\n【被控訴人の主張】\n(ア)  構成要件Ｂ，Ｃ及びＧの文言並びに本件明細書の記載（【００４３】，\n【００６４】，【００６７】，【００７３】，図１０）に照らせば，構\n成要件Ｈの「更新ステップ」においては，文書ファイルに含まれる自ノ\nード変数データが変更される必要がある。\nしかしながら，被告プログラムにおいては，スクリプトの実行により\nｂｅｈａｖｉｏｒ．ｘａｒの値が変更されることはないから，被告プロ\nグラムは，「更新するステップ」を備えておらず，構成要件Ｈを充足し\nない。\n(イ)  以上によれば，被告プログラムは，構成要件ＡないしＨをいずれも\n充足しないから，これを前提とする構成要件Ｉを充足しない。\nしたがって，被告プログラムは，本件発明の技術的範囲に属さない。\n⑵  争点２（無効の抗弁の成否）について\n以下のとおり訂正するほか，原判決の「事実及び理由」の第２の４⑵記載\nのとおりであるから，これを引用する。\nア  原判決１８頁１７行目から１８行目までを「ア  争点２－１（乙９発明\nを主引用例とする本件発明の新規性又は進歩性の欠如）について」と改め\nる。\nイ  原判決１８頁２１行目の「出願時」を「本件特許出願の優先日当時」と\n改める。\nウ  原判決１９頁１２行目の「乙９発明の公報」を「乙９」と，同頁１３行\n目から１４行目にかけての「実質的相違点ではないから，新規性を欠く。」\nを「実質的相違点ではない。したがって，本件発明は，新規性を欠く。」\nと改める。\nエ  原判決１９頁１８行目の「設計事項にすぎないから，」の次に「本件発\n明は，」を加える。\nオ  原判決１９頁２３行目から２４行目にかけての「相違点について」を「相\n違点に係る本件発明の構成が」と，同行目の「よって」から２５行目末尾\nまでを「したがって，被控訴人の主張は理由がない。」と改める。\nカ  原判決１９頁末行から２０頁１行目までを「イ  争点２－２（乙１６発\n明を主引用例とする本件発明の新規性又は進歩性の欠如）について」と改\nめる。\nキ  原判決２０頁４行目の「出願時」を「本件特許出願の優先日当時」と，\n同頁１０行目の「相違点が既存の」を「相違点に係る本件発明の構成が」\nと改める。\nク  原判決２１頁９行目及び１３行目の各「本件明細書等」を「本件明細書」\nと改める。\n⑶  争点３（損害の発生の有無及びその額）について\n以下のとおり訂正するほか，原判決の「事実及び理由」の第２の４⑶記載\nのとおりであるから，これを引用する。\nア  原判決２１頁１９行目，２０行目及び２３行目の各「売上」を「売上げ」\nと改める。\nイ  原判決２１頁２３行目の「本件特許権」を「本件発明」と，同頁２４行\n目の「本件におけるライセンス料率」を「本件発明の実施に対して受ける\nべき金銭の額に相当する損害額を算定するに当たっての実施料率」と改め\nる。\nウ  原判決２２頁１行目の「不法行為」を「本件特許侵害の不法行為」と，\n同頁２行目の「本件特許権のライセンス料（特許法１０２条３項）に相当\nする損害額」を「本件発明の実施に対して受けるべき金銭の額に相当する\n損害額（特許法１０２条３項）」と改める。\n第３  当裁判所の判断\n当裁判所も，控訴人の請求は理由がないものと判断する。その理由は，以下\nのとおりである。\n１  本件明細書の記載事項\n⑴  本件明細書（甲３）の「発明の詳細な説明」には，次のような記載がある\n（下記記載中に引用する図１ないし図４，図６，図１０は，別紙明細書図面\nのとおりである。）。\nア  【技術分野】\n【０００１】\n本発明は，コンピュータを用いて情報を管理する情報管理方法，情報管\n理プログラム，及び情報管理装置に関する。\n【背景技術】\n【０００２】\nコンピュータを用いて各種情報の管理を行う場合，それぞれの情報を記\n憶したファイル（文書ファイル，画像ファイル等）を，所定のフォルダに\n保管することによって行うのが一般的である。しかし，作成したフォルダ\nの構造及びそれぞれのフォルダに保管するファイルの種類等は，任意であ\nってフォルダの作成者に依存するため，作成者以外の者が必要な情報に適\n確にアクセスすることは，必ずしも簡単ではない。すなわち，多数の者が\n情報を共有化し，再利用できるように，情報管理を行うことは容易ではな\nい。\n【０００３】\n特許文献１には，情報の共有化，再利用を効率よく実現することができ\nる文書情報管理システムが記載されている。この文書情報管理システムは，\n案件（プロジェクト）毎にツリーを作成して表示し，作成した文書ファイ\nルを，表示されたツリーの任意のノードに付随させて，サーバコンピュー\nタに保管するものである。\n【０００４】\nまた，異なる計算機やアプリケーションで共通に取扱うことができるデ\nータ形式として，ＸＭＬ（Extensible Markup Language）等の構造化文書\n規格があるが，特許文献２には，このような構造化文書を木構造として捉\nえて処理する構造化文書処理システムが記載されている。\n【０００５】\nしかし，管理される各種情報の更新については，上記した管理システム\nにおいても，効率化が十分図られているとはいえない。すなわち，木構造\nのノードに含まれる情報は，相互に関連するものが多いが，上記した管理\nシステムにおいては，それぞれの文書の該当する部分を個別に更新する必\n要があり，十分効率的とはいえない。\n【０００７】\n本発明は，上記事情に鑑みなされたもので，管理すべき情報の更新を，\n簡単かつ効率的に行うことができる情報管理情報を提供することを目的と\nする。\nイ  【課題を解決するための手段】\n【０００８】\n本発明の情報管理方法は，コンピュータが情報を管理する情報管理方法\nであって，前記コンピュータに複数のノードそれぞれに対応付けて入力さ\nれた管理すべき情報を，前記ノードを識別するノード識別情報に対応付け\nられた複数のノードデータを含む文書ファイルとして前記コンピュータが\n記憶する情報記憶ステップと，前記情報記憶ステップで記憶された前記文\n書ファイルの情報を前記コンピュータが表示する情報表示ステップと，前\n記ノードデータに含まれるスクリプトを前記コンピュータが実行する情報\n評価ステップとを備え，前記ノードデータは，ルートノードを除いて，当\n該ノードの親ノードを特定する親ノード識別情報を含んでおり，前記スク\nリプトは，当該ノードデータに含まれる変数データである自ノード変数デ\nータと，当該ノードの直系上位ノードのノードデータに含まれる変数デー\nタである上位ノード変数データを利用した演算を行って，前記自ノード変\n数データの値を求める代入用スクリプトを含んでおり，前記情報表示ステ\nップは，前記親ノード識別情報を利用して，前記ノードの木構造を表示す\nる木構造表示ステップと，前記表示された木構造のノードのうちの選択さ\nれたノードの前記自ノード変数データ，前記上位ノード変数データ及び前\n記スクリプトを表示するノードデータテーブル表示ステップを含み，\n前記情報評価ステップは，前記代入用スクリプトの実行により，前記自\nノード変数データの値を更新するステップを含むものである。\n【０００９】\n本発明によれば，利用者が入力したデータに含まれるスクリプトを利用\nして，ノードデータを更新することができるので，管理すべき情報の更新\nを，簡単かつ効率的に行うことができる。また，複数のノードデータを含\nむ１つの文書データを用いて，個々の業務や案件に関する情報を管理して\nいるので，多数の利用者による情報の共有化，再利用を，簡単かつ効率的\nに行うことができるとともに，文書データに基づいて，簡単にノードの木\n構造を表示させることができ，業務や案件全体の把握を簡単に行うことが\nできる。さらに，表示された木構造の個々のノードに対応付けられた詳細\n情報を簡単に表示することができる。\n【００１０】\n本発明の情報管理方法は，前記木構造表示ステップが，前記ノードを示\nすノードラベルと，前記親ノードの前記ノードラベルとの間を接続する階\n層リードとの表示を含むものを含む。本発明によれば，ノードの階層関係\nを容易に識別することができる。\n【００１３】\n本発明の情報管理方法は，前記ルートノードの前記ノードデータが，前\n記ルートノードが形成するページを識別する自己ページ番号を含んでお\nり，前記ルートノードを除くノードの前記ノードデータが，当該ノードが\n所属する所属ページを識別する所属ページ番号を含むとともに，当該ノー\nドが形成する自己ページを識別する自己ページ番号を含むことが可能で\nあり，前記木構造表示ステップが，前記自己ページ番号及び前記所属ペー\nジ番号に基づいて，前記ルートノードを先頭とする木構造を表示するとと\nもに，前記自己ページ番号を有する前記ノードを先頭とする木構造を，異\nなるページに表示可能であるものを含む。本発明によれば，大きな木構造\nでも効率よく表示することができ，管理すべき情報の全体構成を容易に把\n握することができる。また，特定のノードから別の木構造を作成すること\nができるので，別の観点の木構造を簡単に作成することができ，管理すべ\nき情報の整理が容易になる。\n【００１５】\n本発明の情報管理方法は，前記ノードデータテーブル表示ステップが，\n当該ノードの直系下位ノードの前記スクリプトでも利用される公開変数\nと，当該ノードの前記スクリプトでのみ利用される限定変数を含むものを\n含む。本発明によれば，必要な変数データのみを下位ノードに継承させる\nことができる。\n【００２２】\n本発明の情報管理プログラムは，上記した情報管理方法における各ステ\nップを，コンピュータに実行させるための情報管理プログラムである。\n【発明の効果】\n【００２４】\n以上の説明から明らかなように，本発明によれば，管理すべき情報の更\n新を，簡単かつ効率的に行うことができる。\nウ  【００２７】\nコンピュータにインストールする情報管理プログラムは，管理すべき情\n報をノードに対応付けて入力する情報入力ステップ，情報入力ステップで\n入力されたデータを，各ノードを識別するノード識別情報に対応付けられ\nた複数のノードデータを含む文書として記憶する情報記憶ステップ，情報\n記憶ステップで記憶された文書の情報を表示する情報表示ステップ，及び\nノードデータに含まれるスクリプトを実行する情報評価ステップを実行す\nるためのプログラムを含んでいる。\n【００２８】\n図１に，ノードデータとして記憶される情報の一例を示す。記憶される\n情報は，ノード番号，ページ番号，親ノード番号，ノードラベル，ノード\n表示属性情報，変数情報，代入用スクリプト，生成用スクリプト，リンク\n情報を含む。\n【００２９】\nノード番号は，ノードを識別する情報であり，ノード生成時に自動的に\n一意の番号が付与される。ページ番号は，文書に含まれるノードを複数の\n木構造として表示するためのもので，そのノードが所属するページを識別\nする所属ページ番号に，そのノードが別のページを形成する場合にそのペ\nージを識別する自己ページ番号を含む。したがって，両方のページ番号が\n記憶されているノードは，２つのページに属することになる。親ノード番\n号は，そのノードの親ノードを識別する番号であり，ノード生成時に親ノ\nードを指定することにより，その指定された親ノードのノード番号が自動\n的に記憶される。\n【００３０】\nノードラベルは，木構造表示時にそのノードを示す情報であり，ノード\n名称等任意の情報を記憶することができる。ノード表示属性情報は，ノー\nド表示時の背景，文字の色，フォント等の文字属性，枠の形状，大きさ等\nの枠属性等を指定する情報である。ここで，ＪＰＧ画像等をノードに表示\nしたい場合は，その画像ファイルの場所を指定するＵＲＬ等が記憶される。\n【００３１】\n変数情報は，各ノードが保持するデータであって，変数名に対応させて\n記憶される。記憶される変数は，下位ノードから参照される公開変数と，\n自ノード内でのみ使用する限定変数を含む。また，変数の値（「変数デー\nタ」と記述する場合もある。）は，固定値が設定されても，スクリプトの\n実行によって演算された値が設定されてもよい。また，ＵＲＬが設定され\nてもよい。どのような値が設定されるかは任意である。\n【００３２】\n代入用スクリプトは，自ノードの変数の値を演算するためのものである。\n代入用スクリプトは，自ノードの変数の値である自ノード変数データと，\nそのノードの直系上位ノードの公開変数の値である上位ノード変数データ\nを利用して記述することが可能である。\n【００３３】\n生成用スクリプトは，辞書に登録してある別のノードやノード群（木構\n造の複数ノード）を利用して，新規にそのノードの下位のノードを生成す\nるものである。生成用スクリプトを条件文と併用することにより，代入用\nスクリプトの実行により求められた変数データの結果によって，子ノード\nや孫ノードを生成することができる。生成用スクリプトを利用することに\nより，例えば，部品管理を行う場合，親部品のサイズによって子部品が変\nわるケースの子部品のデータを簡単に生成することができる。\n【００３４】\nなお，代入用スクリプト及び生成用スクリプトに使用する言語としては，\nスクリプト言語として使用されている任意の言語を使用することができる。\n【００３５】\nリンク情報は，各ノードにリンクするファイルに関する情報である。ス\nタンドアローン型のコンピュータで実施する場合，この情報はリンクファ\nイルのインデックス情報である。また，クライアント− サーバ型のコンピ\nュータで実施する場合，リンクファイルをサーバに転送後，インデックス\n情報を作成し，記憶する。リンク情報を記憶することにより，各ノードを\nフォルダとして利用することが可能となる。\n【００３６】\nノードデータは，例えばタグ付き文書情報として記憶される。図２に，\nノードデータの一例を示す。図２のデータは，ルートノードのノードデー\nタの例であり，ノード番号（nodeNo）が「3450」，自己ページ番号（ownPageNo）\nが「10」，ノードラベル(label)が「パッセル操作マニュアル」である。所\n属ページ番号を示す（ belongPageNo ）が「0 」，親ノード番号を示す\n（parentNodeNo）が「0」であることで，ルートノードであることを示して\nいる。図２の「x=”100”」から「color=”0”」までは，ノードの表示位\n置等のノード表示属性情報である。\n【００３７】\nこの形式では，変数情報が，「<DataDivision>」と「</DataDivision>」\nの間に挿入され，代入用スクリプトが，「<ProcesureDivision>」と「</P\nrocesureDivision>」の間に挿入され，生成用スクリプトが，「<Generate\nDivision>」と「</GenerateDivision>」の間に，リンク情報が，「<Linka\ngeDivision>」と「</LinkageDivision>」の間に挿入される。ただし，図２\nの例では，変数情報，代入用スクリプト，生成用スクリプトは，記憶され\nていない。\n【００３８】\n図３に，ノードデータの別の例を示す。図３のデータは，ルートノード\n以外のノードデータの例である。所属ページ番号が「3484」，親ノード番\n号が「3488」となっており，ルートノード以外のノードのノードデータで\nあることが把握できる。また，自己ページ番号が「3526」となっているこ\nとから，別ページの木構造の先頭ノードであることも把握できる。\n【００３９】\n図４に，管理すべきデータを複数のノードデータを含む文書情報として\n記憶させたものの一例を示す。図４の文書は，ヘッダ部４０，ノードデー\nタ部４１ａ〜４１ｎ，ライン部４２，レポート部４３を備える。\n【００４０】\nヘッダ部４０は，管理される案件等を指すプロジェクトのプロジェクト\n番号，名称（プロジェクト名）等を示す情報を含んでいる。図４の例では，\nプロジェクト名が「Manual ver2」，プロジェクト番号が「10」であること\nを示している。\n【００４１】\nノードデータ部４１ａは，ルートノードのノードデータを示し，ノード\nデータ部４１ｂ〜４１ｎは，ルートノード以外のノードのノードデータで\nある。\n【００４２】\nライン部４２は，ノード間を接続するリードを定義する情報が記憶され\nる領域である。ノード間を接続するリードは，親子のノード間を接続する\n階層リードと，階層関係とは無関係に一時的に変数を参照する参照元ノー\nドと参照先ノード間を接続する参照リードがあるが，ライン部４２は，参\n照リードの存在及び，位置，表示属性等を規定する。\nエ  【００４３】\n次に，記憶された文書情報の表示について説明する。図５に，文書情報\nの表示を行う場合の概略動作フローを示し，図４に示す文書の表示を行っ\nた場合の表示画面の例を図６に示す。\n【００４４】\n図６の表示画面は，ツリービューア１０とデザインテーブル２０を有す\nる。ツリービューア１０は，ノードの木構造を表示する領域であり，情報\n管理時の各種操作を行うためのプルダウンメニュー，及びポップアップメ\nニューを表示する領域も兼ねる。ノードの木構造の表示は，ラベルとリー\nドの表示によって行い，図６の例では，ルートノードのラベル表示１１ａ\nとルートノード以外のノードのラベル表示１１ｂ，１１ｃ，１１ｄと，そ\nれらの間を接続する階層リード１２ｂ，１２ｃ，１２ｄが表示されている。\n【００４５】\nラベル表示１１ａ〜１１ｄは，ノード表示属性情報に基づいて表示され\nるが，ルートノードのラベル表示１１ａには，ルートノードであることを\n示すマーク１３ａが付加される。また，ルートノード以外のノードで自己\nページ番号を有するノードは，その旨を示すマーク１４ｂ，１４ｄが付加\nされる。マーク１４ｂ，１４ｄが付加されていることで，別ページの木構\n造が存在することを簡単に認識することができる。\n【００４６】\nデザインテーブル２０は，ツリービューア１０に表示されたノードのう\nちの選択されたノードが有する情報を表示する領域であり，公開変数表示\n領域２１，限定変数表示領域２２，代入用スクリプト表示領域２３，生成\n用スクリプト表示領域２４，操作ボタン表示領域２１ａ，２２ａ，２０ａ\nを有する。操作ボタン表示領域２１ａの各操作ボタンは，公開変数に対す\nる各種操作を行うためのものであり，操作ボタン表示領域２２ａの各操作\nボタンは，限定変数に対する各種操作を行うためのものである。また，操\n作ボタン表示領域２０ａの各操作ボタンは，デザインテーブル２０に関す\nる各種操作を行うためのものである。\n【００４７】\nプロジェクト毎に作成された文書ファイルを選択し，開くと，図５に示\nす手順で表示処理が行われる。ステップＳ１０１では，文書データからル\nートノードを認識する。既述のように，ルートノードのノードデータは，\n所属ページ番号及び親ページ番号が「０」であるので，そのようなノード\nを探すことにより，ルートノードを認識することができる。なお，文書番\n号を一義的に割り当て，ルートノードの自己ページ番号を文書番号と一致\nさせておくと，ルートノードの認識がさらに簡単になる。\n【００４８】\nステップＳ１０２では，認識したルートノードの自己ノード番号を認識\nし，ステップＳ１０３では，認識したページ番号のページに属するノード\nを認識する。すなわち，ルートノードの自己ページ番号を所属ページ番号\nとして有するノードを認識する。\n【００４９】\n次いで，ステップＳ１０３で認識したノードのラベル表示を行う（ステ\nップＳ１０４）。ラベル表示は，そのノードのノードラベル及びノード表\n示属性情報に基づいて表示する。そして，表示したノードの親子関係に基\nづいて階層リードを表示し，さらに，文書のライン部４２の情報を参考に\nして，参照リードを表示する（ステップＳ１０５）。\n【００５０】\nこの状態では，ツリービューア１０に木構造が表示された状態である。\nステップＳ１０６では，ツリービューア１０に表示されたノードが選択さ\nれたかどうかを判定し，選択されている場合，デザインテーブル２０の表\n示を行い（ステップＳ１０７），そのノードの変数，スクリプト等を表示\nする（ステップＳ１０８）。図６は，ルートノードを選択した場合の例で\nあり，ルートノードには，変数情報等が記憶されていないので，デザイン\nテーブル２０に，データの表示はない。この状態で，別のノードを選択す\nると，そのノードの変数等が表示される。\n【００５１】\n記憶された変数の値が，ＵＲＬ又はファイルパスである場合は，その変\n数を選択した状態で領域２１ａ，２２ａの「実行」ボタンをおすことによ\nり，そのＵＲＬ又はファイルパスの内容を表示する。\n【００５２】\nデザインテーブル２０は，ノードを選択することで表示されるが，各ノ\nードのリンク情報，及びノードレポートの表示は，ノード選択後メニュー\nを表示させて行う。リンク情報表示が指示されると，そのノードのノード\nデータのリンク情報のリストを別ウィンドウで表示する。リンク情報が記\n憶されていない場合は，リストが空欄である。表示されたリストの中のフ\nァイルが選択されると，そのファイルの内容に応じた情報の表示を行う。\nノードレポート表示が指示されると，別ウィンドウに表示するとともに，\nレポート領域４３を参照し，該当ノードの情報が記憶されている場合には，\nその情報を表示した別のウィンドウに表示する。\n【００５３】\nノードのリンク情報，及びノードレポートは，リンク情報のリスト，あ\nるいはレポート表示ウィンドウを表示した状態で，追加，削除を行うこと\nができる。\nオ  【００５４】\n図６に示した状態で，表示された木構造及びノードデータの編集が可能\nであり，編集操作に対応した表示を行う（ステップＳ１０９）。ツリービ\nューア１０上では，ノードの追加，削除，表示位置移動，表示属性変更，\nノードラベル変更等を，プルダウンメニュー，ポップアップメニューの設\n定により行う。例えば，表示位置の変更は，ラベル表示をドラッグするこ\nとによって行い，ノードラベル及び表示属性の変更は，変更用のウィンド\nウを表示させて行う。また，ノードの削除は，削除したいノードを選択し\nた状態で，メニューを表示させて削除する。ノードの追加は，メニューで\n追加モードに設定後，追加したいノードの親となるノードを選択し，その\nままドラッグすることにより，新規ノードを生成する。また，ノードの繋\nぎ換えは，繋ぎ換えたいノードを選択し，メニューを表示させて「ノード\n繋ぎ換え」を選択し，変更したい繋ぎ先のノード（親ノードとしたいノー\nド）を選択することによって行う。生成されたノードのノードラベル，表\n示属性情報は，修正用のウィンドウを表示させて設定する。\n【００５５】\nそれぞれのノードに関するデータは，ノードデータとして１まとまりに\nなっているので，これらの編集を行った場合でも，編集を行ったノードの\nノードデータに反映させるだけでよく，軽い処理負担で編集作業を行うこ\nとができる。\n【００５６】\nデザインテーブルの情報を追加，修正する場合は，領域２１ａ，２２ａ，\n２０ａの該当するボタンを押すことによって行う。変数の追加は，領域２\n１ａ又は２２ａ「追加」ボタンを押して，新規の変数を生成し，変数名，\n値，修飾情報を入力する。変数の入力は，別ウィンドウで入力フォームを\n表示させて行ってもよい。\n【００５７】\n代入用スクリプト及び生成用スクリプトは，公開変数領域２１および限\n定変数領域２２に表示された変数を利用して作成する。公開変数領域２１\nには，自ノードの公開変数だけでなく，直系上位のすべてのノードの公開\n変数が表示される。直系上位のノード以外のノードの変数を参照したい場\n合は，参照リードを生成して，参照先のノードと関連付けておく。代入用\nスクリプト及び生成用スクリプトは代入用スクリプト領域２３及び生成用\nスクリプト領域２４に直接入力してもよいし，別のウィンドウを開いて入\n力するようにしてもよい。\n【００５８】\nなお，デザインテーブル２０の編集内容は，領域２０ａの更新ボタンを\n押すことによって，文書情報に反映される。\n【００５９】\n続いて，ステップＳ１１０では，表示終了，すなわち文書クローズが指\n示されたかどうかを判定し，表示終了が支持されていない場合は，階層移\n動指示がされているか否かを判定する（ステップＳ１１１）。階層移動は，\nマーク１４ｂ，１４ｄ等別の木構造の先頭ノードとなるノードを選択した\n状態で，ポップアップメニューから指示する。\n【００６０】\n階層移動が指示されていると判定した場合，ステップＳ１１２で別ペー\nジの木構造を表示する。木構造の表示は，表示すべきページ番号を認識後，\nステップＳ１０３〜ステップＳ１０５の処理と同様の処理を行う。木構造\nの先頭でないノードに対して階層移動が指示される（階層を降りる旨の指\n示）と，そのノードを先頭とするノードを表示する。その時のページ番号\nは，そのノードの自己ページ番号である。木構造の先頭ノードを選択して\n階層移動を指示すると，そのノードの所属ページ番号が示すページの木構\n造を表示する。\nカ  【００６４】\n図８から明らかなように，部分「fore」は，３つの「ＭＷ70 巾木(表)」\nと３つの「ＭＷ70 パネル(表)」から構成される。図９に，１つの部品「Ｍ\nＷ70 巾木(表)」に対応するノード（図８では，便宜的に右肩に「＊」を付\nしてある。）のノードデータの一部を示し，図１０に，そのノードが選択\nされた場合の公開変数表示領域２１の表示例を，図１１に，限定変数表示\n領域の表示例を示す。\n【００６５】\n公開変数表示領域に表示される公開変数は，自ノードの公開変数５１と，\n直系上位ノードの公開変数５２を含み，直系上位のノードの公開変数５２\nは，自ノードの公開変数５１と異なる色で表示される（図１０では，フォ\nントを変えて示してある。）。また，公開変数には，固定値が入力される\n公開変数と，代入用スクリプトの実行によって計算される公開変数があり，\n修飾領域に「なし」あるいは「要計算」を表示することによりに区別され\nる。\n【００６６】\n要計算の公開変数の値は，後述するように代入用スクリプトが実行され\nるまでは空欄であり，図９及び図１０は，代入用スクリプト実行前の状態\nを示している。なお，直系上位ノードに要計算の公開変数が含まれ，その\n公開変数の値が代入スクリプトの実行前で定まっていない場合，その公開\n変数は，下位ノードの公開変数領域２１に表示されない。すなわち，他の\nノードからの参照が一時停止される。\n【００６７】\n代入用スクリプト及び生成用スクリプトは，操作ボタン表示領域２０ａ\nの「評価」ボタンを押すことにより実行される。図１２に，スクリプト実\n行時の概略動作フローを示す。スクリプトを実行したいターゲットのノー\nド選択し，「評価」ボタンが押されると，評価条件設定用のダイアログボ\nックスを表示する（ステップＳ３０１）。このダイアログボックスでは，\n評価対象スクリプトの種類と，評価階層が少なくとも可能となっている。\nすなわち，代入用スクリプトのみの実行，生成用スクリプトの実行，両ス\nクリプトの実行の設定と，自ノードのみを評価するか直系下位ノードの指\n定階層まで評価するかを設定する。\n【００７１】\nステップＳ３０７で，スクリプトを実行すべきノードが残っていると判\n断された場合は，ステップＳ３０３に戻り，下位のノードについて同様の\n判断を行い，スクリプトの実行を行う。\nキ  【００７２】\n次に，代入用スクリプト及び生成用スクリプトの具体例を，図８の「＊」\nを付したノードをターゲットノードとして説明する。図９に示すように，\nターゲットノードは，要計算の公開変数として，「スライス数」と「色」\nを有しており，代入用スクリプトとして，「スライス数＝同一面数；」と\n「色＝同一面数」を有している。評価前は，図１０に示すように，公開変\n数「スライス数」と「色」の値は空欄となっている。\n【００７３】\nこの状態で，このノードを選択し，「評価ボタン」を押し，評価条件と\nして代入用スクリプトの実行を設定すると，記憶された代入用スクリプト\nを実行する。したがって，公開変数「スライス数」の値は，上位ノードの\n公開変数である「同一面数」の値「１」となり，公開変数「色」の値は，\n同様に上位ノードの公開変数である「巾木色」の値「Ｆ− ２０５」となる。\n代入用スクリプト実行後のデザインテーブルの公開変数表示領域２１の表\n示例を，図１３に示す。\n⑵  前記⑴の記載事項によれば，本件明細書には，本件発明に関し，次のとお\nりの開示があることが認められる。\nア  コンピュータを用いて各種情報の管理を行う場合，それぞれの情報を記\n憶したファイルを，所定のフォルダに保管することによって行うのが一般\n的であるが，作成したフォルダの構造及びそれぞれのフォルダに保管する\nファイルの種類等は，任意であってフォルダの作成者に依存するため，作\n成者以外の者が必要な情報に適確にアクセスすることは簡単ではなく，多\n数の者が情報を共有化し，再利用できるように，情報管理を行うことは容\n易ではない（【０００２】）。\nまた，従来，案件（プロジェクト）毎にツリーを作成して表示し，作成\nした文書ファイルを表示されたツリーの任意のノードに付随させてサーバ\nコンピュータに保管することができる文書情報管理システムや，異なる計\n算機やアプリケーションで共通に取扱うことができるＸＭＬ等の構造化文\n書を木構造として捉えて処理する構造化文書処理システムが存在したが，\n木構造のノードに含まれる情報は，相互に関連するものが多いにもかかわ\nらず，上記各システムにおいては，それぞれの文書の該当する部分を個別\nに更新する必要があり，管理される各種情報の更新として，十分効率的と\nはいえなかった（【０００３】ないし【０００５】）。\nイ  「本発明」は，上記事情に鑑み，管理すべき情報の更新を，簡単かつ効\n率的に行うことができる情報管理方法を提供することを目的とするもので\nあり，その課題を解決する手段として，コンピュータが情報を管理する情\n報管理方法であって，前記コンピュータに複数のノードそれぞれに対応付\nけて入力された管理すべき情報を，前記ノードを識別するノード識別情報\nに対応付けられた複数のノードデータを含む文書ファイルとして前記コン\nピュータが記憶する情報記憶ステップと，前記情報記憶ステップで記憶さ\nれた前記文書ファイルの情報を前記コンピュータが表示する情報表示ステ\nップと，前記ノードデータに含まれるスクリプトを前記コンピュータが実\n行する情報評価ステップとを備え，前記ノードデータは，ルートノードを\n除いて，当該ノードの親ノードを特定する親ノード識別情報を含んでおり，\n前記スクリプトは，当該ノードデータに含まれる変数データである自ノー\nド変数データと，当該ノードの直系上位ノードのノードデータに含まれる\n変数データである上位ノード変数データを利用した演算を行って，前記自\nノード変数データの値を求める代入用スクリプトを含んでおり，前記情報\n表示ステップは，前記親ノード識別情報を利用して，前記ノードの木構造\nを表示する木構造表示ステップと，前記表示された木構造のノードのうち\nの選択されたノードの前記自ノード変数データ，前記上位ノード変数デー\nタ及び前記スクリプトを表示するノードデータテーブル表示ステップを含\nみ， 前記情報評価ステップは，前記代入用スクリプトの実行により，前記\n自ノード変数データの値を更新するステップを含むという構成を採用した\n（【０００７】，【０００８】）。\n「本発明」によれば，利用者が入力したデータに含まれるスクリプトを\n利用してノードデータを更新し，管理すべき情報の更新を簡単かつ効率的\nに行うことができ，また，複数のノードデータを含む１つの文書データを\n用いて個々の業務や案件に関する情報を管理しているので，多数の利用者\nによる情報の共有化，再利用を，簡単かつ効率的に行うことができるとと\nもに，文書データに基づいて，簡単にノードの木構造を表示させることが\nでき，業務や案件全体の把握を簡単に行うことができる上，表示された木\n構造の個々のノードに対応付けられた詳細情報を簡単に表示することがで\nきるため，管理すべき情報の更新を，簡単かつ効率的に行うことができる\nという効果を奏する（【０００９】，【００２４】）。\n２  争点１（被告プログラムの本件発明の技術的範囲の属否）について\n本件の事案に鑑み，まず，争点１－２について判断し，次いで争点１－４に\nついて判断する。\n⑴  争点１－２（構成要件Ｅの充足性）について\nア  被告プログラムについて\n原判決３３頁１５行目の「１７，」及び同頁１７行目の「(ア)  」を削\nるほか，同頁１５行目から３４頁２行目までに記載のとおりであるから，\nこれを引用する。\nイ  構成要件Ｅの「ルートノード」の意義について\n(ア)  本件発明の構成要件Ｅの「前記ノードデータは，ルートノードを除\nいて，当該ノードの親ノードを特定する親ノード識別情報を含んでおり」\nとの記載によれば，「親ノード識別情報」は「ノードの親ノードを特定\nする」識別情報であり，「当該ノード」の「ノードデータ」に含まれて\nいることを理解できる。\nそして，本件発明の特許請求の範囲には，「ノードデータ」に関し，\n「前記コンピュータに複数のノードそれぞれに対応付けて入力された管\n理すべき情報を，前記ノードを識別するノード識別情報に対応付けられ\nた複数のノードデータを含む文書ファイルとして前記コンピュータが記\n憶する情報記憶ステップ」（構成要件Ｂ），「親ノード識別情報」に関\nし，「前記情報表示ステップは，前記親ノード識別情報を利用して，前\n記ノードの木構造を表示する木構造表示ステップ」（構成要件Ｇ）との\n記載がある。これらの構成要件Ｂ及びＧの記載によれば，本件発明にお\nいては，「複数のノード」が「木構造」を有し，各「ノード」は当該ノ\nードを識別する「ノード識別情報」を有すること，「親ノード識別情報」\nは，「木構造」における親子関係にあるノードの親ノードを識別する情\n報であることを理解できる。\nそして，構成要件Ｅの記載から，本件発明には，「ルートノード」と\n「ルートノード」以外の「ノード」が存在し，「ルートノード」以外の\n「ノード」の「ノードデータ」は，「親ノード識別情報」を含んでいる\nが，「ルートノード」の「ノードデータ」は，「親ノード識別情報」を\n含んでいないことを理解できる。\n(イ)  本件明細書には，「ルートノード」を定義した記載はないが，「ル\nートノード」に関し，「…前記木構造表示ステップが，前記自己ページ\n番号及び前記所属ページ番号に基づいて，前記ルートノードを先頭とす\nる木構造を表示するとともに，…」（【００１３】），「ノードデータ\nは，例えばタグ付き文書情報として記憶される。図２に，ノードデータ\nの一例を示す。図２のデータは，ルートノードのノードデータの例であ\nり，ノード番号（nodeNo）が「3450」，自己ページ番号（ownPageNo）\nが「10」，ノードラベル(label)が「パッセル操作マニュアル」である。\n所属ページ番号を示す（belongPageNo）が「0」，親ノード番号を示す\n（parentNodeNo）が「0」であることで，ルートノードであることを示\nしている。」（【００３６】），「…図４の文書は，ヘッダ部４０，ノ\nードデータ部４１ａ〜４１ｎ，ライン部４２，レポート部４３を備え\nる。」（【００３９】），「ノードデータ部４１ａは，ルートノードの\nノードデータを示し，ノードデータ部４１ｂ～４１ｎは，ルートノード\n以外のノードのノードデータである。」（【００４１】），「ライン部\n４２は，ノード間を接続するリードを定義する情報が記憶される領域で\nある。ノード間を接続するリードは，親子のノード間を接続する階層リ\nードと，階層関係とは無関係に一時的に変数を参照する参照元ノードと\n参照先ノード間を接続する参照リードがある…」（【００４２】），「図\n６の表示画面は，ツリービューア１０とデザインテーブル２０を有する。\nツリービューア１０は，ノードの木構造を表示する領域であり，情報管\n理時の各種操作を行うためのプルダウンメニュー，及びポップアップメ\nニューを表示する領域も兼ねる。ノードの木構造の表示は，ラベルとリ\nードの表示によって行い，図６の例では，ルートノードのラベル表示１\n１ａとルートノード以外のノードのラベル表示１１ｂ，１１ｃ，１１ｄ\nと，それらの間を接続する階層リード１２ｂ，１２ｃ，１２ｄが表示さ\nれている。」（【００４４】）との記載がある。\nそして，図４には，ノードデータ部４１ａの「ｎｏｄｅＮｏ」が「３\n４５０」の「ノード」は，「ルートノード」であり，「ｐａｒｅｎｔＮ\nｏｄｅＮｏ」が「０」であること，ノードデータ部４１ｂの「ｎｏｄｅ\nＮｏ」が「３４５１」の「ノード」は，「ｐａｒｅｎｔＮｏｄｅＮｏ」\nが「３４５０」であることが示されている。また，図６には，ルートノ\nードのラベル表示１１ａが，階層関係にあるノードの最初のノードとし\nて表示されており，親ノードに当たるノードが存在しないことが示され\nている。\nこれらの記載から，本件明細書には，「ルートノード」は，階層関係\nにあるノードの「木構造」の先頭のノードであり，親ノードに当たるノ\nードが存在しないこと，このため，「ルートノード」のノードデータの\n親ノード番号（「ｐａｒｅｎｔＮｏｄｅＮｏ」）「０」は，親ノードを\n特定する識別情報には当たらないことが開示されていることが認めら\nれる。\n(ウ)  以上の本件発明の特許請求の範囲の記載及び本件明細書の記載によ\nれば，構成要件Ｅの「ルートノード」は，階層関係にあるノードの「木\n構造」の先頭のノードであって，そのノードデータに親ノードを特定す\nる「親ノード識別情報」が含まないものであると解される。\nウ  控訴人の主張について\n控訴人は，本件ｂｅｈａｖｉｏｒ．ｘａｒ１（別紙３－２）及び本件ｂ\nｅｈａｖｉｏｒ．ｘａｒ２（別紙７－１）の記載に基づいて，被告プログ\nラムにおけるボックスにおいては，当該ボックスが属する順序系列内にお\nける一番最初のボックスであって，当該ボックスの入力コネクタと他のボ\nックスの出力コネクタとの結合情報を持たないボックスが存在し，このボ\nックスは，構成要件Ｅの「ルートノード」に該当する旨主張するので，以\n下において判断する。\n(ア)  本件ｂｅｈａｖｉｏｒ．ｘａｒ１について\nａ  被告プログラムにより，本件ロボットに「こんにちは」を意味する\n単語をしゃべらせる振る舞いを構築した際に作成されたｂｅｈａｖｉ\nｏｒ．ｘａｒが本件ｂｅｈａｖｉｏｒ．ｘａｒ１（別紙３－２）であ\nり，この内容をフローダイアグラムとして示したものが，別紙６の図\n１ないし図３である。\n本件ｂｅｈａｖｉｏｒ．ｘａｒ１で記述されるＳａｙボックスは，\n別紙６の図１に示され，ＳａｙボックスのｏｎＳｔａｒｔコネクタと\nｏｎＳｔｏｐｐｅｄコネクタの間のフローダイアグラムは，別紙６の\n図２のとおり，①ＳａｙボックスのｏｎＳｔａｒｔコネクタ，②Ｌｏ\nｃａｌｉｚｅｄ  Ｔｅｘｔボックス，③Ｓａｙ  Ｔｅｘｔボックス，\n④ＳａｙボックスのｏｎＳｔｏｐｐｅｄコネクタの順にリードで接続\nされている。\n本件ｂｅｈａｖｉｏｒ．ｘａｒ１においては，ｒｏｏｔボックス（３\n行ないし３０８行）の階層，ｒｏｏｔボックスに包含されるＳｅｔ  Ｌ\nａｎｇｕａｇｅボックス（１８行ないし９１行）及びＳａｙボックス\n（９２行ないし３００行）の階層並びにＳａｙボックスに包含される\nＳａｙ  Ｔｅｘｔボックス（１２５行ないし１７９行）及びＬｏｃａ\nｌｉｚｅｄ  Ｔｅｘｔボックス（１８０行ないし２９１行）の階層が\n存在し，各ボックスを識別するために割り振られたｉｄは，ｒｏｏｔ\nボックスが「－１」（３行），Ｓｅｔ  Ｌａｎｇｕａｇｅボックスが\n「２」（１８行），Ｓａｙボックスが「１」（９２行），Ｓａｙ  Ｔ\nｅｘｔボックスが「２」（１２５行），Ｌｏｃａｌｉｚｅｄ  Ｔｅｘ\nｔボックスが「５」（１８０行）である。\nそして，上記各ボックス間の結合情報については，２９２行ないし\n２９４行及び３０１行ないし３０３行の「＜Ｌｉｎｋ  ｉｎｐｕｔｏ\nｗｎｅｒ＝…／＞」という形式で記載されたＬｉｎｋタグ内において，\n「ｉｎｐｕｔｏｗｎｅｒ」が入力側のボックスのｉｄを，「ｏｕｔｐ\nｕｔｏｗｎｅｒ」が出力側のボックスのｉｄをそれぞれ表している。\nただし，２９２行及び２９３行のＬｉｎｋタグ内においては，Ｓａｙ\nボックスのｉｄが「１」から「０」に，３０２行及び３０３行のＬｉ\nｎｋタグ内においては，ｒｏｏｔボックスのｉｄが「－１」から「０」\nに，それぞれ置き換えられている。\n「292: <Link inputowner=\"0\" indexofinput=\"4\" outputowner=\"2\"\nindexofoutput=\"4\" />\n293: <Link inputowner=\"5\" indexofinput=\"2\" outputowner=\"0\"\nindexofoutput=\"2\" />\n294: <Link inputowner=\"2\" indexofinput=\"2\" outputowner=\"5\"\nindexofoutput=\"3\" />」\n「301: <Link inputowner=\"1\" indexofinput=\"2\" outputowner=\"2\"\nindexofoutput=\"3\" />\n302: <Link inputowner=\"0\" indexofinput=\"4\" outputowner=\"1\"\nindexofoutput=\"4\" />\n303: <Link inputowner=\"2\" indexofinput=\"2\" outputowner=\"0\"\nindexofoutput=\"2\" />」\nｂ  前記ａの認定事実によれば，本件ｂｅｈａｖｉｏｒ．ｘａｒ１にお\nけるボックス間の結合関係は，Ｌｉｎｋタグ内の「ｉｎｐｕｔｏｗｎ\nｅｒ」及び「ｏｕｔｐｕｔｏｗｎｅｒ」のｉｄを用いて，本件発明の\n「親ノード」に相当する結合元のボックスを識別する情報（「ｏｕｔ\nｐｕｔｏｗｎｅｒ」の番号）と本件発明の（子）「ノード」に相当す\nる結合先のボックスを識別する情報（「ｉｎｐｕｔｏｗｎｅｒ」の番\n号）とにより示されていること，本件ｂｅｈａｖｉｏｒ．ｘａｒ１の\n３０２行においては，ｉｄが「０」のｒｏｏｔボックスの結合元であ\nる親としてｉｄが「１」のＳａｙボックスが記述されていることが認\nめられる。\nｃ  控訴人は，本件ｂｅｈａｖｉｏｒ．ｘａｒ１記載のボックスのうち，\n当該ボックスが属する順序系列内における一番最初のボックスであっ\nて，当該ボックスの入力コネクタと他のボックスの出力コネクタとの\n結合情報を持たないボックスが，構成要件Ｅの「ルートノード」に該\n当する旨主張するところ，具体的にどのボックスが「ルートノード」\nに該当するのか明示していないが，「ｒｏｏｔボックスタグ内の結合\n情報」を取り上げて主張を構築していることに照らすと，「ｒｏｏｔ\nボックス」が「ルートノード」に該当する旨主張しているものと解さ\nれる。\nしかるところ，前記ｂ認定のとおり，本件ｂｅｈａｖｉｏｒ．ｘａ\nｒ１には，ｒｏｏｔボックスの結合情報（Ｌｉｎｋタグ内の「ｉｎｐ\nｕｔｏｗｎｅｒ」及び「ｏｕｔｐｕｔｏｗｎｅｒ」のｉｄ）として，\n結合元である親を示すＳａｙボックスのｉｄである「１」が記述され\nており，このｉｄ「１」は，ｒｏｏｔボックスの親ノードを特定する\n「親ノード識別情報」に該当するものと認められる。\nそうすると，ｒｏｏｔボックスは，そのノードデータに「親ノード\n識別情報」が含まないものとはいえないから，構成要件Ｅの「ルート\nノード」に該当しない。\n(イ)  別紙７－１の本件ｂｅｈａｖｉｏｒ．ｘａｒ２について\nａ  本件ｂｅｈａｖｉｏｒ．ｘａｒ２（別紙７－１）も，被告プログラ\nムにより，本  件ロボットに「こんにちは」を意味する単語をしゃべ\nらせる振る舞いを構築した際に作成されたｂｅｈａｖｉｏｒ．ｘａｒ\nであるが，本件ｂｅｈａｖｉｏｒ．ｘａｒ１と異なり，フローダイア\nグラムボックスが存在しないものである。\n本件ｂｅｈａｖｉｏｒ．ｘａｒ２の内容をフローダイアグラムとし\nて示したものが，別紙７－２である。\n本件ｂｅｈａｖｉｏｒ．ｘａｒ２においては，ｒｏｏｔボックス（３\n行ないし２６７行）の階層並びにｒｏｏｔボックスに包含されるＳｅ\nｔ  Ｌａｎｇｕａｇｅボックス（１８行ないし９１行），Ｓａｙ  Ｔ\nｅｘｔボックス（９２行ないし１４６行）及びＬｏｃａｌｉｚｅｄ  Ｔ\nｅｘｔボックス（１４７行ないし２５８行）の階層が存在し，各ボッ\nクスを識別するために割り振られたｉｄは，ｒｏｏｔボックスが「－\n１」（３行），Ｓｅｔ  Ｌａｎｇｕａｇｅボックスが「２」（１８行），\nＳａｙ  Ｔｅｘｔボックスが「３」（９２行），Ｌｏｃａｌｉｚｅｄ\nＴｅｘｔボックスが「５」（１４７行）である。\nそして，上記各ボックス間の結合情報については，２５９行ないし\n２６２行のＬｉｎｋタグ内において，次のとおり記述されている。前\n記(ア)ｂと同様に，Ｌｉｎｋタグ内において，「ｉｎｐｕｔｏｗｎｅ\nｒ」が入力側のボックスのｉｄを，「ｏｕｔｐｕｔｏｗｎｅｒ」が出\n力側のボックスのｉｄをそれぞれ表している。ただし，２６１行及び\n２６２行のＬｉｎｋタグ内においては，ｒｏｏｔボックスのｉｄが「－\n１」から「０」に置き換えられている。\n「259: <Link inputowner=\"3\" indexofinput=\"2\" outputowner=\"5\"\nindexofoutput=\"3\" />\n260: <Link inputowner=\"5\" indexofinput=\"2\" outputowner=\"2\"\nindexofoutput=\"3\" />\n261: <Link inputowner=\"2\" indexofinput=\"2\" outputowner=\"0\"\nindexofoutput=\"2\" />\n262: <Link inputowner=\"0\" indexofinput=\"4\" outputowner=\"3\"\nindexofoutput=\"4\" />」\nｂ  前記ａの認定事実によれば，本件ｂｅｈａｖｉｏｒ．ｘａｒ２にお\nけるボックス間の結合関係も，本件ｂｅｈａｖｉｏｒ．ｘａｒ１と同\n様に，「ｏｕｔｐｕｔｏｗｎｅｒ」の番号と「ｉｎｐｕｔｏｗｎｅｒ」\nの番号）により示されていること，本件ｂｅｈａｖｉｏｒ．ｘａｒ２\nの２６２行においては，ｉｄが「０」のｒｏｏｔボックスの結合元と\nしてｉｄが「３」のＳａｙ  Ｔｅｘｔボックスが記述されていること\nが認められる。\nｃ  控訴人は，前記(ア)と同様に，本件ｂｅｈａｖｉｏｒ．ｘａｒ２記\n載のボックスのうち，具体的にどのボックスが「ルートノード」に該\n当するのか明示していないが，「ｒｏｏｔボックスタグ内の結合情報」\nを取り上げて主張を構築していることに照らすと，「ｒｏｏｔボック\nス」が「ルートノード」に該当する旨主張しているものと解される。\nしかるところ，前記ｂ認定のとおり，本件ｂｅｈａｖｉｏｒ．ｘａ\nｒ２には，ｒｏｏｔボックスの結合情報（Ｌｉｎｋタグ内の「ｉｎｐ\nｕｔｏｗｎｅｒ」及び「ｏｕｔｐｕｔｏｗｎｅｒ」のｉｄ）として，\n結合元である親を示すＳａｙ  Ｔｅｘｔボックスのｉｄである「３」\nが記述されており，このｉｄ「３」は，ｒｏｏｔボックスの親ノード\nを特定する「親ノード識別情報」に該当するものと認められる。\nそうすると，ｒｏｏｔボックスは，そのノードデータに「親ノード\n識別情報」が含まないものとはいえないから，構成要件Ｅの「ルート\nノード」に該当しない。\n(ウ)  以上によれば，被告プログラムは構成要件Ｅの「ルートノード」に\n該当するボックスを備えているとの控訴人の主張は，理由がない。\nエ  小括\n以上のとおり，被告プログラムは，構成要件Ｅの「ルートノード」に該\n当する構成を備えているものと認められないから，同構成要件を充足しな\nい。\n⑵  争点１－４（構成要件Ｇの充足性）について\nア  構成要件Ｇの「木構造表示ステップ」について\n控訴人は，被告プログラムは，Ｌｉｎｋタグ内のｉｎｐｕｔｏｗｎｅｒ\n（入力側・子）とｏｕｔｐｕｔｏｗｎｅｒ（出力側・親）により結合情報\nを認識し，これに従ってフローダイアグラム上でボックスとボックス間の\n結合線で表現することによって「木構造」を表示しており，「親ノード識\n別情報」を利用して「ノード」の「木構造」を表示しているといえるから，\n被告プログラムは，構成要件Ｇの「前記親ノード識別情報を利用して，前\n記ノードの木構造を表示する木構造表示ステップ」を備えている旨主張す\nる。\nそこで検討するに，本件発明は，「複数のノード」が「木構造」を有し\nていること，このノードの「木構造」の先頭のノードが構成要件Ｅの「ル\nートノード」であることは，前記(1)イ(ア)及び(ウ)認定のとおりである。\nしかるところ，前記(1)ウ認定のとおり，被告プログラムは，構成要件Ｅ\nの「ルートノード」に該当する構成を備えているものと認められないから，\n被告プログラムは，「複数のノード」が「木構造」を有しているものと認\nめることはできない。\nそうすると，控訴人が挙げるフローダイアグラム上のボックスとボック\nス間の結合線の表現（表示）は，本件発明のノードの「木構造」の表示に\n当たるものと認めることはできないから，被告プログラムが構成要件Ｇの\n「前記親ノード識別情報を利用して，前記ノードの木構造を表示する木構\n造表示ステップ」を備えているとの控訴人の上記主張は理由がない。\nイ  構成要件Ｇの「ノードデータテーブル表示ステップ」について\n(ア)  構成要件Ｇの「前記上位ノード変数データ」の意義について\nａ  本件発明の構成要件Ｆの「前記スクリプトは，当該ノードデータに\n含まれる変数データである自ノード変数データと，当該ノードの直系\n上位ノードのノードデータに含まれる変数データである上位ノード変\n数データを利用した演算を行って，前記自ノード変数データの値を求\nめる代入用スクリプトを含んでおり」との記載及び構成要件Ｇの「前\n記表示された木構造のノードのうちの選択されたノードの前記自ノー\nド変数データ，前記上位ノード変数データ及び前記スクリプトを表示\nするノードデータテーブル表示ステップ」との記載から，本件発明の\n「上位ノード変数データ」は，「当該ノードの直系上位ノードのノー\nドデータに含まれる変数データ」であり，構成要件Ｆの「前記自ノー\nド変数データの値」を求める「代入用スクリプト」による演算に利用\nされる「変数データ」であることを理解できる。\n次に，本件明細書には，「上位ノード変数データ」に関し，「変数\n情報は，各ノードが保持するデータであって，変数名に対応させて記\n憶される。記憶される変数は，下位ノードから参照される公開変数と，\n自ノード内でのみ使用する限定変数を含む。また，変数の値（「変数\nデータ」と記述する場合もある。）は，固定値が設定されても，スク\nリプトの実行によって演算された値が設定されてもよい。また，ＵＲ\nＬが設定されてもよい。どのような値が設定されるかは任意である。」\n（【００３１】），「代入用スクリプトは，自ノードの変数の値を演\n算するためのものである。代入用スクリプトは，自ノードの変数の値\nである自ノード変数データと，そのノードの直系上位ノードの公開変\n数の値である上位ノード変数データを利用して記述することが可能で\nある。」（【００３２】），「公開変数表示領域に表示される公開変\n数は，自ノードの公開変数５１と，直系上位ノードの公開変数５２を\n含み，直系上位のノードの公開変数５２は，自ノードの公開変数５１\nと異なる色で表示される（図１０では，フォントを変えて示してある。）。\nまた，公開変数には，固定値が入力される公開変数と，代入用スクリ\nプトの実行によって計算される公開変数があり，修飾領域に「なし」\nあるいは「要計算」を表示することによりに区別される。」（【００\n６５】）との記載がある。\nそして，図１０には，「直系上位ノードの公開変数の値である上位\nノード変数データ」として，「５２」に「変数名」及びそれに対応す\nる「値」が示されている（例えば，「変数名」の欄「パネル色」・「値」\n欄「ＫＷ－４００」）。\nこれらの記載によれば，本件明細書には，「上位ノード変数データ」\nにいう「変数データ」は，「変数の値」を含むデータであることの開\n示があることが認められる。\n以上の本件発明の特許請求の範囲の記載及び本件明細書の記載によ\nれば，構成要件Ｇの「前記表示された木構造のノードのうちの選択さ\nれたノードの前記自ノード変数データ，前記上位ノード変数データ及\nび前記スクリプトを表示するノードデータテーブル表示ステップ」に\nいう「前記上位ノード変数データ」は，「当該ノードの直系上位ノー\nドのノードデータ」に含まれる「変数の値」を含むデータであると解\nされる。\nｂ  これに対し控訴人は，本件明細書の【００３２】における「変数の\n値（「変数データ」と記述する場合もある。）」との記載は，「変数\nデータ」という用語を，文脈によって，変数の値を指す意味で用いる\nこともあるという注意書きであると理解できること，「変数データ」\nは，変数名と変数の型を意味するというのが，プログラミングに関す\nる通常の用語であること（甲２４），実質的にも，本件発明が「ノー\nドデータテーブル表示ステップ」において上位ノード変数データを表\n示させる目的は，表示された木構造の個々のノードに対応付けられた\n詳細情報を簡単に表示することができる（【０００９】）ことにより，\n文書ファイル（プログラム）の編集を容易にする点にあり，変数名が\n分かれば，その目的を達成することができることからすると，本件発\n明の「上位ノード変数データ」は，本件明細書において文脈上変数の\n値を意味すべき場合を除き，変数名を指すと解すべきである旨主張す\nる。\nしかしながら，本件明細書には，「上位ノード変数データ」が変数\n名のみで構成される場合を含むことについての記載や示唆はない。\nまた，前記ａの本件明細書の記載に照らすと，【００３２】の「変\n数の値（「変数データ」と記述する場合もある。）」との記載は，「変\n数データ」は「変数の値」を意味することを示した記載であると解す\nるのが自然であり，これが変数の値を指す意味で用いることもあると\nいう注意書きであるということはできない。\nしたがって，控訴人の上記主張は採用することができない。\n(イ)  被告プログラムにおける「ノードデータテーブル表示ステップ」の\n有無について\nａ  控訴人は，入力コネクタは，親ボックスから引き渡される値を記憶\nする変数が図形化されたものであり，入力コネクタの名称が構成要件\nＧにおける「上位ノード変数データ」に該当すること，インスペクタ\n及びスクリプトエディタに表示される入力コネクタの名称に関する\n情報の表示は，上位ノード変数データを表示するものであることから\nすると，被告プログラムは，「上位ノード変数データ」を表示する「ノ\nードデータテーブル表示ステップ」を備えている旨主張する。\nしかしながら，前記(ア)ａ認定のとおり，構成要件Ｇの「前記上位\nノード変数データ」は，「当該ノードの直系上位ノードのノードデー\nタ」に含まれる「変数の値」を含むデータであると認められるところ，\n入力コネクタの名称は，「変数の値」であるとはいえないから，控訴\n人の上記主張は，その前提を欠くものであり，理由がない。\nｂ  控訴人は，被告プログラムの構成ｇ’に関し，被告プログラムのＳ\nａｙ  Ｔｅｘｔボックスの「スクリプトエディタ」において「親から\nの変数を取得」機能を使う場合，上位ノードであるＳａｙボックスの\n変数から利用可能なものを一覧表示する機能があるから，被告プログ\nラムは，「上位ノード変数データ」を表示する「ノードデータテーブ\nル表示ステップ」を備えている旨主張する。\nしかしながら，控訴人の上記主張は，「スクリプトエディタ」にお\nいて，どのような「上位ノード変数データ」が表示されるのかについ\nて具体的に主張するものではないから，その主張自体理由がない。\nｃ  以上によれば，被告プログラムは，「上位ノード変数データ」を表\n示する「ノードデータテーブル表示ステップ」を備えているものと認\nめることはできないから，構成要件Ｇの「前記表示された木構造のノ\nードのうちの選択されたノードの前記自ノード変数データ，前記上位\nノード変数データ及び前記スクリプトを表示するノードデータテーブ\nル表示ステップ」を備えているものと認めることはできない。\nウ  まとめ\n以上のとおり，被告プログラムは，構成要件Ｇの「木構造を表示する木\n構造表示ステップ」及び「ノードデータテーブル表示ステップ」を備えて\nいるものと認められないから，構成要件Ｇを充足しない。\n(3)  小括\n以上によれば，被告プログラムは，本件発明の構成要件Ｅ及びＧを充足し\nないから，その余の点について判断するまでもなく，本件発明の技術的範囲\nに属するものと認めることはできない。\nしたがって，その余の点について判断するまでもなく，控訴人の請求は理\n由がない。\n３  結論\n以上のとおり，控訴人の請求は理由がないから，控訴人の請求を棄却した原\n判決は相当である。\nしたがって，本件控訴は理由がないからこれを棄却することとし，主文のと\nおり判決する。\n知的財産高等裁判所第４部\n裁判長裁判官      大    鷹    一    郎\n裁判官      國    分    隆    文\n裁判官      筈    井    卓    矢\n（別紙）\nプ  ロ  グ  ラ  ム  目  録\n名    称   Ｃｈｏｒｅｇｒａｐｈｅ（コレグラフ）\nバージョン   ２．３及び２．４\n対 象 Ｏ Ｓ   Ｍａｃ  ＯＳ，Ｗｉｎｄｏｗｓ及びＬｉｎｕｘ\n（別紙７－１）\n（別紙７－２）\n（別紙）\n明細書図面\n【図１】\n【図２】\n【図３】\n【図４】\n【図６】\n【図１０】\n"
}